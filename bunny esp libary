local playersService = game:GetService("Players")
local workspaceService = game:GetService("Workspace")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")

local espModule = {}
espModule.__index = espModule

espModule.Config = {
TeamCheck = true,
ESPDistance = 1000,
BoxColor = Color3.new(0.403922, 0.34902, 0.701961),
BoxGradientEnabled = true,
BoxGradientColor1 = Color3.fromRGB(200, 0, 255),
BoxGradientColor2 = Color3.fromRGB(100, 150, 255),
BoxGradientColor3 = Color3.fromRGB(100, 255, 200),
BoxFillTransparency = 0.6,
RotateSpeed = 120,
BoxOutlineEnabled = true,
BoxOutlineGradientEnabled = true,
BoxOutlineColor = Color3.new(0, 0, 0),
BoxOutlineGradient1 = Color3.fromRGB(255, 100, 255),
BoxOutlineGradient2 = Color3.fromRGB(100, 200, 255),
BoxOutlineGradient3 = Color3.fromRGB(100, 255, 200),
SkeletonColor = Color3.new(0.403922, 0.34902, 0.701961),
ChamsColor = Color3.new(0.403922, 0.34902, 0.701961),
ChamsFillTransparency = 0.5,
ChamsOutlineColor = Color3.new(1, 1, 1),
WireframeColor = Color3.new(0.403922, 0.34902, 0.701961),
WireframeThickness = 1,
TracerOrigin = "Bottom Screen",
TracerColor = Color3.new(0.403922, 0.34902, 0.701961),
HealthBarLerpSpeed = 0.15,
PositionLerpSpeed = 0.3,
ColorLerpSpeed = 0.1,
HealthColorFull = Color3.fromRGB(0, 255, 0),
HealthColorMid = Color3.fromRGB(255, 255, 0),
HealthColorLow = Color3.fromRGB(255, 0, 0),
HealthBarGradientEnabled = true,
HealthBarGradient1 = Color3.fromRGB(255, 0, 0),
HealthBarGradient2 = Color3.fromRGB(255, 255, 0),
HealthBarGradient3 = Color3.fromRGB(0, 255, 0),
ArmorBarColor = Color3.fromRGB(0, 150, 255),
RingColor = Color3.fromRGB(255, 255, 255),
ScanSpeed = 2.5,
ScanHeight = 3.5,
RingRadius = 2.5
}

espModule.State = {
BoxEnabled = false,
NameEnabled = false,
DistanceEnabled = false,
SkeletonEnabled = false,
HealthTextEnabled = false,
HealthBarEnabled = false,
ArmorBarEnabled = false,
TracerEnabled = false,
ChamsEnabled = false,
WireframeEnabled = false,
RingEnabled = false,
GUIEnabled = true,
OutlineGradientEnabled = true,
FillGradientEnabled = true,
HealthGradientEnabled = true
}

espModule.Caches = {
BoxCache = {},
SkeletonCache = {},
TracerCache = {},
ChamsCache = {},
WireframeCache = {},
RingCache = {}
}

local localPlayer = playersService.LocalPlayer
local currentCamera = workspaceService.CurrentCamera
local heartbeatConnection = nil
local renderConnection = nil
local currentRotation = 0

local BODY_PARTS = {
"Head", "Torso", "UpperTorso", "LowerTorso",
"Left Arm", "Right Arm", "LeftUpperArm", "LeftLowerArm", "LeftHand",
"RightUpperArm", "RightLowerArm", "RightHand",
"Left Leg", "Right Leg", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
"RightUpperLeg", "RightLowerLeg", "RightFoot"
}

local CUBE_EDGES = {
{1, 2}, {2, 3}, {3, 4}, {4, 1},
{5, 6}, {6, 7}, {7, 8}, {8, 5},
{1, 5}, {2, 6}, {3, 7}, {4, 8},
{1, 3}, {2, 4}, {5, 7}, {6, 8},
{1, 6}, {2, 5}, {4, 7}, {3, 8},
{1, 8}, {4, 5}, {2, 7}, {3, 6}
}

local TOTAL_LINES = #CUBE_EDGES

local function safeCall(cb)
local s, e = pcall(cb)
if not s then warn("MatchaEsp Error: " .. tostring(e)) end
end

local function lerpNumber(a, b, t)
return a + (b - a) * math.clamp(t, 0, 1)
end

local function lerpVector2(a, b, t)
return Vector2.new(lerpNumber(a.X, b.X, t), lerpNumber(a.Y, b.Y, t))
end

local function lerpColor3(a, b, t)
return Color3.new(lerpNumber(a.R, b.R, t), lerpNumber(a.G, b.G, t), lerpNumber(a.B, b.B, t))
end

local function getHealthColor(hp, cfg)
if hp > 50 then
return lerpColor3(cfg.HealthColorMid, cfg.HealthColorFull, (hp - 50) / 50)
elseif hp > 25 then
return lerpColor3(cfg.HealthColorLow, cfg.HealthColorMid, (hp - 25) / 25)
else
return cfg.HealthColorLow
end
end

local function getCameraDistance(pos)
return (currentCamera.CFrame.Position - pos).Magnitude
end

local function isAnyBoxFeatureEnabled(self)
return self.State.BoxEnabled or self.State.NameEnabled or self.State.DistanceEnabled or
self.State.HealthTextEnabled or self.State.HealthBarEnabled or self.State.ArmorBarEnabled
end

local function isTeammate(self, p)
if not self.Config.TeamCheck then return false end
if not localPlayer.Team or not p.Team then return false end
return p.Team == localPlayer.Team
end

local function isValidTarget(self, p)
if p == localPlayer then return false end
local c = p.Character
if not c then return false end
local r = c:FindFirstChild("HumanoidRootPart")
if not r then return false end
local h = c:FindFirstChild("Humanoid")
if not h or h.Health <= 0 then return false end
if getCameraDistance(r.Position) > self.Config.ESPDistance then return false end
if isTeammate(self, p) then return false end
return true
end

local function getBoxCorners(part)
local cf, sz = part.CFrame, part.Size
local sx, sy, sz2 = sz.X/2, sz.Y/2, sz.Z/2
return {
cf * CFrame.new(-sx, -sy, -sz2), cf * CFrame.new(sx, -sy, -sz2),
cf * CFrame.new(sx, -sy, sz2), cf * CFrame.new(-sx, -sy, sz2),
cf * CFrame.new(-sx, sy, -sz2), cf * CFrame.new(sx, sy, -sz2),
cf * CFrame.new(sx, sy, sz2), cf * CFrame.new(-sx, sy, sz2)
}
end

local function worldToScreen(pos)
local sp, on = currentCamera:WorldToViewportPoint(pos)
return Vector2.new(sp.X, sp.Y), on, sp.Z
end

function espModule:CreateBox(_)
local bd = {
Box = Drawing.new("Square"), BoxOutline = Drawing.new("Square"),
Name = Drawing.new("Text"), Distance = Drawing.new("Text"), HealthText = Drawing.new("Text"),
HealthBarBackground = Drawing.new("Square"), HealthBar = Drawing.new("Square"),
HealthBarOutline = Drawing.new("Square"), ArmorText = Drawing.new("Text"),
ArmorBarBackground = Drawing.new("Square"), ArmorBar = Drawing.new("Square"),
ArmorBarOutline = Drawing.new("Square"),
FillFrame = Instance.new("Frame"), Gradient = Instance.new("UIGradient"),
Stroke = Instance.new("UIStroke"), OutlineFrame = Instance.new("Frame"),
OutlineGradient = Instance.new("UIGradient"), OutlineStroke = Instance.new("UIStroke"),
HealthBarFrame = Instance.new("Frame"), HealthBarInner = Instance.new("Frame"),
HealthBarInnerGradient = Instance.new("UIGradient"),
CurrentHealth = 100, TargetHealth = 100, CurrentArmor = 0, TargetArmor = 0,
CurrentHealthColor = self.Config.HealthColorFull, TargetHealthColor = self.Config.HealthColorFull,
CurrentPosition = Vector2.new(0, 0), TargetPosition = Vector2.new(0, 0),
CurrentSize = Vector2.new(0, 0), TargetSize = Vector2.new(0, 0), Initialized = false
}



bd.FillFrame.Parent = self.EspGui
bd.FillFrame.BorderSizePixel = 0
bd.FillFrame.BackgroundTransparency = 1
bd.FillFrame.Visible = false
bd.Gradient.Parent = bd.FillFrame
bd.Gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, self.Config.BoxGradientColor1),
    ColorSequenceKeypoint.new(0.5, self.Config.BoxGradientColor2),
    ColorSequenceKeypoint.new(1, self.Config.BoxGradientColor3)
})
bd.Gradient.Rotation = 45
bd.Stroke.Parent = bd.FillFrame
bd.Stroke.Thickness = 1
bd.Stroke.Color = self.Config.BoxOutlineColor
bd.Stroke.Transparency = 0.1
bd.Stroke.Enabled = self.Config.BoxOutlineEnabled

bd.OutlineFrame.Parent = self.EspGui
bd.OutlineFrame.BorderSizePixel = 0
bd.OutlineFrame.BackgroundTransparency = 1
bd.OutlineFrame.Visible = false
bd.OutlineGradient.Parent = bd.OutlineFrame
bd.OutlineGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, self.Config.BoxOutlineGradient1),
    ColorSequenceKeypoint.new(0.5, self.Config.BoxOutlineGradient2),
    ColorSequenceKeypoint.new(1, self.Config.BoxOutlineGradient3)
})
bd.OutlineGradient.Rotation = 45
bd.OutlineStroke.Parent = bd.OutlineFrame
bd.OutlineStroke.Thickness = 1
bd.OutlineStroke.Color = Color3.fromRGB(255, 255, 255)
bd.OutlineStroke.Transparency = 0.05

bd.HealthBarFrame.Parent = self.EspGui
bd.HealthBarFrame.BorderSizePixel = 0
bd.HealthBarFrame.BackgroundTransparency = 0.5
bd.HealthBarFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
bd.HealthBarFrame.Visible = false
bd.HealthBarFrame.ClipsDescendants = true

bd.HealthBarInner.Parent = bd.HealthBarFrame
bd.HealthBarInner.BorderSizePixel = 0
bd.HealthBarInner.BackgroundTransparency = 0
bd.HealthBarInner.BackgroundColor3 = Color3.new(1, 1, 1)
bd.HealthBarInner.AnchorPoint = Vector2.new(0, 1)
bd.HealthBarInner.Position = UDim2.new(0, 0, 1, 0)
bd.HealthBarInner.Size = UDim2.new(1, 0, 1, 0)

bd.HealthBarInnerGradient.Parent = bd.HealthBarInner
bd.HealthBarInnerGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, self.Config.HealthBarGradient3),
    ColorSequenceKeypoint.new(0.5, self.Config.HealthBarGradient2),
    ColorSequenceKeypoint.new(1, self.Config.HealthBarGradient1)
})
bd.HealthBarInnerGradient.Rotation = 0

bd.Box.Thickness = 1
bd.Box.Color = self.Config.BoxColor
bd.Box.Filled = false
bd.Box.Visible = false
bd.Box.Transparency = 1

bd.BoxOutline.Thickness = 1.5
bd.BoxOutline.Color = self.Config.BoxOutlineColor
bd.BoxOutline.Filled = false
bd.BoxOutline.Visible = false
bd.BoxOutline.Transparency = 1

bd.Name.Size = 14
bd.Name.Color = Color3.new(1, 1, 1)
bd.Name.Outline = true
bd.Name.OutlineColor = Color3.new(0, 0, 0)
bd.Name.Center = true
bd.Name.Visible = false
bd.Name.Font = 2
bd.Name.Transparency = 1

bd.Distance.Size = 13
bd.Distance.Color = Color3.fromRGB(200, 200, 200)
bd.Distance.Outline = true
bd.Distance.OutlineColor = Color3.new(0, 0, 0)
bd.Distance.Center = true
bd.Distance.Visible = false
bd.Distance.Font = 2
bd.Distance.Transparency = 1

bd.HealthText.Size = 12
bd.HealthText.Color = Color3.new(1, 1, 1)
bd.HealthText.Outline = true
bd.HealthText.OutlineColor = Color3.new(0, 0, 0)
bd.HealthText.Center = false
bd.HealthText.Visible = false
bd.HealthText.Font = 2
bd.HealthText.Transparency = 1

bd.HealthBarBackground.Thickness = 1
bd.HealthBarBackground.Color = Color3.fromRGB(20, 20, 20)
bd.HealthBarBackground.Filled = true
bd.HealthBarBackground.Visible = false
bd.HealthBarBackground.Transparency = 0.5

bd.HealthBarOutline.Thickness = 1
bd.HealthBarOutline.Color = Color3.fromRGB(80, 80, 80)
bd.HealthBarOutline.Filled = false
bd.HealthBarOutline.Visible = false
bd.HealthBarOutline.Transparency = 0.3

bd.HealthBar.Thickness = 1
bd.HealthBar.Color = self.Config.HealthColorFull
bd.HealthBar.Filled = true
bd.HealthBar.Visible = false
bd.HealthBar.Transparency = 0.2

bd.ArmorText.Size = 12
bd.ArmorText.Color = self.Config.ArmorBarColor
bd.ArmorText.Outline = true
bd.ArmorText.OutlineColor = Color3.new(0, 0, 0)
bd.ArmorText.Center = false
bd.ArmorText.Visible = false
bd.ArmorText.Font = 2
bd.ArmorText.Transparency = 1

bd.ArmorBarBackground.Thickness = 1
bd.ArmorBarBackground.Color = Color3.fromRGB(20, 20, 20)
bd.ArmorBarBackground.Filled = true
bd.ArmorBarBackground.Visible = false
bd.ArmorBarBackground.Transparency = 0.5

bd.ArmorBarOutline.Thickness = 1
bd.ArmorBarOutline.Color = Color3.fromRGB(80, 80, 80)
bd.ArmorBarOutline.Filled = false
bd.ArmorBarOutline.Visible = false
bd.ArmorBarOutline.Transparency = 0.3

bd.ArmorBar.Thickness = 1
bd.ArmorBar.Color = self.Config.ArmorBarColor
bd.ArmorBar.Filled = true
bd.ArmorBar.Visible = false
bd.ArmorBar.Transparency = 1

return bd
end

function espModule:CreateSkeleton(tp)
local tc = tp.Character
local isR6 = tc and tc:FindFirstChild("Torso") and not tc:FindFirstChild("UpperTorso")
local sd = {IsR6 = isR6, Lines = {}, CurrentPositions = {}, TargetPositions = {}}



local lineNames = isR6 and {"HeadToTorso", "TorsoToLeftArm", "TorsoToRightArm", "TorsoToLeftLeg", "TorsoToRightLeg"}
    or {"HeadToUpperTorso", "UpperTorsoToLowerTorso", "UpperTorsoToLeftUpperArm", "LeftUpperArmToLeftLowerArm",
        "LeftLowerArmToLeftHand", "UpperTorsoToRightUpperArm", "RightUpperArmToRightLowerArm", "RightLowerArmToRightHand",
        "LowerTorsoToLeftUpperLeg", "LeftUpperLegToLeftLowerLeg", "LeftLowerLegToLeftFoot",
        "LowerTorsoToRightUpperLeg", "RightUpperLegToRightLowerLeg", "RightLowerLegToRightFoot"}

for _, n in ipairs(lineNames) do
    local l = Drawing.new("Line")
    l.Thickness = 2
    l.Color = self.Config.SkeletonColor
    l.Visible = false
    l.Transparency = 1
    sd.Lines[n] = l
    sd.CurrentPositions[n.."From"] = Vector2.new(0, 0)
    sd.CurrentPositions[n.."To"] = Vector2.new(0, 0)
    sd.TargetPositions[n.."From"] = Vector2.new(0, 0)
    sd.TargetPositions[n.."To"] = Vector2.new(0, 0)
end
sd.Initialized = false
return sd
end

function espModule:CreateTracer(_)
local td = {
Line = Drawing.new("Line"),
CurrentFrom = Vector2.new(0, 0), CurrentTo = Vector2.new(0, 0),
TargetFrom = Vector2.new(0, 0), TargetTo = Vector2.new(0, 0), Initialized = false
}
td.Line.Thickness = 1.5
td.Line.Color = self.Config.TracerColor
td.Line.Visible = false
td.Line.Transparency = 1
return td
end

function espModule:CreateChams(tp)
local h = Instance.new("Highlight")
h.FillColor = self.Config.ChamsColor
h.OutlineColor = self.Config.ChamsOutlineColor
h.FillTransparency = self.Config.ChamsFillTransparency
h.OutlineTransparency = 0
h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
h.Parent = tp.Character
h.Adornee = tp.Character
return h
end

function espModule:CreateWireframe(tp)
local wd = {Parts = {}, Lines = {}}
for _, pn in ipairs(BODY_PARTS) do
wd.Lines[pn] = {}
for i = 1, TOTAL_LINES do
local l = Drawing.new("Line")
l.Thickness = self.Config.WireframeThickness
l.Color = self.Config.WireframeColor
l.Visible = false
l.Transparency = 1
wd.Lines[pn][i] = l
end
end
return wd
end

function espModule:CreateRing(p)
if p == localPlayer then return nil end
local h = Instance.new("Part")
h.Name = "ESP_Holder_" .. p.Name
h.Transparency = 1
h.CanCollide = false
h.Anchored = true
h.Parent = workspace
local r = Instance.new("CylinderHandleAdornment")
r.Adornee = h
r.AlwaysOnTop = true
r.ZIndex = 10
r.Color3 = self.Config.RingColor
r.InnerRadius = self.Config.RingRadius - 0.1
r.Radius = self.Config.RingRadius
r.Height = 0.08
r.CFrame = CFrame.Angles(math.rad(90), 0, 0)
r.Parent = h
r.Visible = false
return {Holder = h, Ring = r, Root = nil}
end

function espModule:ClearBox(tp)
local c = self.Caches.BoxCache[tp]
if c then
pcall(function() c.Box:Remove() end)
pcall(function() c.BoxOutline:Remove() end)
pcall(function() c.Name:Remove() end)
pcall(function() c.Distance:Remove() end)
pcall(function() c.HealthText:Remove() end)
pcall(function() c.HealthBarBackground:Remove() end)
pcall(function() c.HealthBar:Remove() end)
pcall(function() c.HealthBarOutline:Remove() end)
pcall(function() c.ArmorText:Remove() end)
pcall(function() c.ArmorBarBackground:Remove() end)
pcall(function() c.ArmorBar:Remove() end)
pcall(function() c.ArmorBarOutline:Remove() end)
pcall(function() c.FillFrame:Destroy() end)
pcall(function() c.OutlineFrame:Destroy() end)
pcall(function() c.HealthBarFrame:Destroy() end)
self.Caches.BoxCache[tp] = nil
end
end

function espModule:ClearSkeleton(tp)
local c = self.Caches.SkeletonCache[tp]
if c then
for _, l in pairs(c.Lines) do pcall(function() l:Remove() end) end
self.Caches.SkeletonCache[tp] = nil
end
end

function espModule:ClearTracer(tp)
local c = self.Caches.TracerCache[tp]
if c then pcall(function() c.Line:Remove() end) self.Caches.TracerCache[tp] = nil end
end

function espModule:ClearChams(tp)
local c = self.Caches.ChamsCache[tp]
if c then pcall(function() c:Destroy() end) self.Caches.ChamsCache[tp] = nil end
end

function espModule:ClearWireframe(tp)
local c = self.Caches.WireframeCache[tp]
if c then
for _, ls in pairs(c.Lines) do for _, l in ipairs(ls) do pcall(function() l:Remove() end) end end
self.Caches.WireframeCache[tp] = nil
end
end

function espModule:ClearRing(tp)
local c = self.Caches.RingCache[tp]
if c then pcall(function() c.Holder:Destroy() end) self.Caches.RingCache[tp] = nil end
end

function espModule:ClearAllBoxes() for p in pairs(self.Caches.BoxCache) do self:ClearBox(p) end end
function espModule:ClearAllSkeletons() for p in pairs(self.Caches.SkeletonCache) do self:ClearSkeleton(p) end end
function espModule:ClearAllTracers() for p in pairs(self.Caches.TracerCache) do self:ClearTracer(p) end end
function espModule:ClearAllChams() for p in pairs(self.Caches.ChamsCache) do self:ClearChams(p) end end
function espModule:ClearAllWireframes() for p in pairs(self.Caches.WireframeCache) do self:ClearWireframe(p) end end
function espModule:ClearAllRings() for p in pairs(self.Caches.RingCache) do self:ClearRing(p) end end

function espModule:HideBox(tp)
local bd = self.Caches.BoxCache[tp]
if bd then
bd.Box.Visible = false
bd.BoxOutline.Visible = false
bd.FillFrame.Visible = false
bd.OutlineFrame.Visible = false
bd.HealthBarFrame.Visible = false
bd.Name.Visible = false
bd.Distance.Visible = false
bd.HealthText.Visible = false
bd.HealthBar.Visible = false
bd.HealthBarBackground.Visible = false
bd.HealthBarOutline.Visible = false
bd.ArmorText.Visible = false
bd.ArmorBar.Visible = false
bd.ArmorBarBackground.Visible = false
bd.ArmorBarOutline.Visible = false
if bd.Stroke then bd.Stroke.Enabled = false end
end
end

function espModule:HideSkeleton(tp)
local c = self.Caches.SkeletonCache[tp]
if c then for _, l in pairs(c.Lines) do l.Visible = false end end
end

function espModule:HideTracer(tp)
local c = self.Caches.TracerCache[tp]
if c then c.Line.Visible = false end
end

function espModule:HideWireframe(tp)
local c = self.Caches.WireframeCache[tp]
if c then for _, ls in pairs(c.Lines) do for _, l in ipairs(ls) do l.Visible = false end end end
end

function espModule:HideRing(tp)
local c = self.Caches.RingCache[tp]
if c and c.Ring then c.Ring.Visible = false end
end

function espModule:UpdateBox(dt)
if not self or not self.State or not self.Config or not self.Caches then return end
if not isAnyBoxFeatureEnabled(self) then self:ClearAllBoxes() return end
if not localPlayer.Character then self:ClearAllBoxes() return end
local lr = localPlayer.Character:FindFirstChild("HumanoidRootPart")
if not lr then self:ClearAllBoxes() return end


local ap = {}
local pl = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
local cl = math.clamp(self.Config.ColorLerpSpeed * dt * 60, 0, 1)
local hl = math.clamp(self.Config.HealthBarLerpSpeed * dt * 60, 0, 1)

for _, op in ipairs(playersService:GetPlayers()) do
    if op ~= localPlayer then
        ap[op] = true
        local ok, _ = pcall(function()
            if not isValidTarget(self, op) then self:ClearBox(op) return end
            
            local oc = op.Character
            local or2 = oc:FindFirstChild("HumanoidRootPart")
            local oh = oc:FindFirstChild("Humanoid")
            local dist = getCameraDistance(or2.Position)
            
            if not self.Caches.BoxCache[op] then self.Caches.BoxCache[op] = self:CreateBox(op) end
            local bd = self.Caches.BoxCache[op]
            local rsp, ron = currentCamera:WorldToViewportPoint(or2.Position)
            if not ron then self:HideBox(op) return end
            
            local hp = oc:FindFirstChild("Head")
            local htp = (hp and hp.Position + Vector3.new(0, 0.8, 0)) or (or2.Position + Vector3.new(0, 2.5, 0))
            local fp = or2.Position - Vector3.new(0, 3, 0)
            local htsp = currentCamera:WorldToViewportPoint(htp)
            local fsp = currentCamera:WorldToViewportPoint(fp)
            
            local h = math.abs(htsp.Y - fsp.Y)
            local w = h * 0.55
            local cp = Vector2.new(rsp.X, (htsp.Y + fsp.Y) / 2)
            local ttl = cp - Vector2.new(w / 2, h / 2)
            local tsz = Vector2.new(w, h)
            
            if not bd.Initialized then
                bd.CurrentPosition = ttl
                bd.CurrentSize = tsz
                bd.Initialized = true
            else
                bd.CurrentPosition = lerpVector2(bd.CurrentPosition, ttl, pl)
                bd.CurrentSize = lerpVector2(bd.CurrentSize, tsz, pl)
            end
            
            local stl = bd.CurrentPosition
            local ssz = bd.CurrentSize
            local sw, sh = ssz.X, ssz.Y
            local scx = stl.X + sw / 2
            
            local chv = oh.Health
            local mhv = oh.MaxHealth
            local hpp = (chv / mhv) * 100
            
            bd.TargetHealth = hpp
            bd.CurrentHealth = lerpNumber(bd.CurrentHealth, bd.TargetHealth, hl)
            local thc = getHealthColor(bd.CurrentHealth, self.Config)
            bd.CurrentHealthColor = lerpColor3(bd.CurrentHealthColor, thc, cl)
            
            if self.State.BoxEnabled then
                bd.Box.Visible = false
                bd.BoxOutline.Visible = false
                bd.FillFrame.Visible = false
                bd.OutlineFrame.Visible = false
                
                if self.Config.BoxGradientEnabled and self.State.FillGradientEnabled then
                    bd.FillFrame.Position = UDim2.fromOffset(stl.X, stl.Y)
                    bd.FillFrame.Size = UDim2.fromOffset(sw, sh)
                    bd.FillFrame.BackgroundTransparency = self.Config.BoxFillTransparency
                    bd.FillFrame.Visible = true
                    bd.Stroke.Enabled = false
                end
                
                if self.State.OutlineGradientEnabled and self.Config.BoxOutlineEnabled then
                    bd.OutlineFrame.Position = UDim2.fromOffset(stl.X, stl.Y)
                    bd.OutlineFrame.Size = UDim2.fromOffset(sw, sh)
                    bd.OutlineFrame.BackgroundTransparency = 1
                    bd.OutlineFrame.Visible = true
                    if bd.OutlineStroke then bd.OutlineStroke.Enabled = true end
                elseif self.Config.BoxOutlineEnabled and not self.State.OutlineGradientEnabled then
                    bd.BoxOutline.Size = Vector2.new(sw, sh)
                    bd.BoxOutline.Position = stl
                    bd.BoxOutline.Color = self.Config.BoxOutlineColor
                    bd.BoxOutline.Visible = true
                end
            else
                bd.Box.Visible = false
                bd.BoxOutline.Visible = false
                bd.FillFrame.Visible = false
                bd.OutlineFrame.Visible = false
                if bd.Stroke then bd.Stroke.Enabled = false end
            end
            
            if self.State.NameEnabled then
                bd.Name.Position = Vector2.new(scx, stl.Y - 18)
                bd.Name.Text = op.Name
                bd.Name.Visible = true
            else bd.Name.Visible = false end
            
            if self.State.DistanceEnabled then
                bd.Distance.Position = Vector2.new(scx, stl.Y + sh + 3)
                bd.Distance.Text = math.floor(dist) .. "m"
                bd.Distance.Visible = true
            else bd.Distance.Visible = false end
            
            local bx = stl.X - 6
            local by = stl.Y
            
            if self.State.HealthBarEnabled or self.State.HealthTextEnabled then
                local dh = math.floor(bd.CurrentHealth)
                
                if self.State.HealthTextEnabled then
                    local ty = by + sh * (1 - bd.CurrentHealth / 100)
                    ty = math.clamp(ty, by, by + sh - 10)
                    bd.HealthText.Position = Vector2.new(bx - 18, ty - 6)
                    bd.HealthText.Text = tostring(dh)
                    bd.HealthText.Color = bd.CurrentHealthColor
                    bd.HealthText.Visible = true
                else bd.HealthText.Visible = false end
                
                if self.State.HealthBarEnabled then
                    local hr = bd.CurrentHealth / 100
                    
                    if self.State.HealthGradientEnabled then
                        bd.HealthBar.Visible = false
                        bd.HealthBarBackground.Visible = false
                        bd.HealthBarOutline.Visible = false
                        bd.HealthBarFrame.Position = UDim2.fromOffset(bx - 1, by - 1)
                        bd.HealthBarFrame.Size = UDim2.fromOffset(5, sh + 2)
                        bd.HealthBarFrame.Visible = true
                        bd.HealthBarInner.Size = UDim2.new(1, 0, hr, 0)
                    else
                        bd.HealthBarFrame.Visible = false
                        local bh = sh * hr
                        bd.HealthBarOutline.Size = Vector2.new(5, sh + 2)
                        bd.HealthBarOutline.Position = Vector2.new(bx - 1.5, by - 1)
                        bd.HealthBarOutline.Visible = true
                        bd.HealthBarBackground.Size = Vector2.new(3, sh)
                        bd.HealthBarBackground.Position = Vector2.new(bx - 0.5, by)
                        bd.HealthBarBackground.Visible = true
                        bd.HealthBar.Size = Vector2.new(3, bh)
                        bd.HealthBar.Position = Vector2.new(bx - 0.5, by + sh - bh)
                        bd.HealthBar.Color = bd.CurrentHealthColor
                        bd.HealthBar.Visible = bh > 0
                    end
                else
                    bd.HealthBar.Visible = false
                    bd.HealthBarBackground.Visible = false
                    bd.HealthBarOutline.Visible = false
                    bd.HealthBarFrame.Visible = false
                end
            else
                bd.HealthText.Visible = false
                bd.HealthBar.Visible = false
                bd.HealthBarBackground.Visible = false
                bd.HealthBarOutline.Visible = false
                bd.HealthBarFrame.Visible = false
            end
            
            if self.State.ArmorBarEnabled then
                local be = oc:FindFirstChild("BodyEffects")
                local av = (be and be:FindFirstChild("Armor")) and be.Armor.Value or 0
                local ap2 = math.clamp((av / 200) * 100, 0, 100)
                bd.TargetArmor = ap2
                bd.CurrentArmor = lerpNumber(bd.CurrentArmor, bd.TargetArmor, hl)
                local abx = stl.X + sw + 2
                local abh = sh * (bd.CurrentArmor / 100)
                bd.ArmorBarOutline.Size = Vector2.new(5, sh + 2)
                bd.ArmorBarOutline.Position = Vector2.new(abx - 1.5, by - 1)
                bd.ArmorBarOutline.Visible = true
                bd.ArmorBarBackground.Size = Vector2.new(3, sh)
                bd.ArmorBarBackground.Position = Vector2.new(abx - 0.5, by)
                bd.ArmorBarBackground.Visible = true
                bd.ArmorBar.Size = Vector2.new(3, abh)
                bd.ArmorBar.Position = Vector2.new(abx - 0.5, by + sh - abh)
                bd.ArmorBar.Color = self.Config.ArmorBarColor
                bd.ArmorBar.Visible = bd.CurrentArmor > 0
                if self.State.HealthTextEnabled and bd.CurrentArmor > 0 then
                    local aty = by + sh * (1 - bd.CurrentArmor / 100)
                    aty = math.clamp(aty, by, by + sh - 10)
                    bd.ArmorText.Position = Vector2.new(abx + 6, aty - 6)
                    bd.ArmorText.Text = tostring(math.floor(bd.CurrentArmor))
                    bd.ArmorText.Color = self.Config.ArmorBarColor
                    bd.ArmorText.Visible = true
                else bd.ArmorText.Visible = false end
            else
                bd.ArmorBar.Visible = false
                bd.ArmorBarBackground.Visible = false
                bd.ArmorBarOutline.Visible = false
                bd.ArmorText.Visible = false
            end
        end)
        if not ok then self:ClearBox(op) end
    end
end
for p in pairs(self.Caches.BoxCache) do if not ap[p] then self:ClearBox(p) end end
end

function espModule:UpdateSkeleton(dt)
if not self.State.SkeletonEnabled then self:ClearAllSkeletons() return end
if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then self:ClearAllSkeletons() return end



local ap = {}
local pl = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)

for _, op in ipairs(playersService:GetPlayers()) do
    if op ~= localPlayer then
        ap[op] = true
        if not isValidTarget(self, op) then self:ClearSkeleton(op) continue end
        local oc = op.Character
        if not self.Caches.SkeletonCache[op] then self.Caches.SkeletonCache[op] = self:CreateSkeleton(op) end
        local sd = self.Caches.SkeletonCache[op]
        
        local function gsp(pn)
            local p = oc:FindFirstChild(pn)
            if p then
                local sp, on = currentCamera:WorldToViewportPoint(p.Position)
                return Vector2.new(sp.X, sp.Y), on
            end
            return Vector2.new(0, 0), false
        end
        
        local function ul(ln, fp, tp, fo, to)
            local l = sd.Lines[ln]
            if not l then return end
            sd.TargetPositions[ln.."From"] = fp
            sd.TargetPositions[ln.."To"] = tp
            if not sd.Initialized then
                sd.CurrentPositions[ln.."From"] = fp
                sd.CurrentPositions[ln.."To"] = tp
            else
                sd.CurrentPositions[ln.."From"] = lerpVector2(sd.CurrentPositions[ln.."From"], fp, pl)
                sd.CurrentPositions[ln.."To"] = lerpVector2(sd.CurrentPositions[ln.."To"], tp, pl)
            end
            l.From = sd.CurrentPositions[ln.."From"]
            l.To = sd.CurrentPositions[ln.."To"]
            l.Color = self.Config.SkeletonColor
            l.Visible = fo and to
        end
        
        if sd.IsR6 then
            local hp, ho = gsp("Head")
            local tp, to2 = gsp("Torso")
            local lap, lao = gsp("Left Arm")
            local rap, rao = gsp("Right Arm")
            local llp, llo = gsp("Left Leg")
            local rlp, rlo = gsp("Right Leg")
            if ho and to2 then
                ul("HeadToTorso", hp, tp, ho, to2)
                ul("TorsoToLeftArm", tp, lap, to2, lao)
                ul("TorsoToRightArm", tp, rap, to2, rao)
                ul("TorsoToLeftLeg", tp, llp, to2, llo)
                ul("TorsoToRightLeg", tp, rlp, to2, rlo)
            else self:HideSkeleton(op) end
        else
            local hp, ho = gsp("Head")
            local utp, uto = gsp("UpperTorso")
            local ltp, lto = gsp("LowerTorso")
            local luap, luao = gsp("LeftUpperArm")
            local llap, llao = gsp("LeftLowerArm")
            local lhp, lho = gsp("LeftHand")
            local ruap, ruao = gsp("RightUpperArm")
            local rlap, rlao = gsp("RightLowerArm")
            local rhp, rho = gsp("RightHand")
            local lulp, lulo = gsp("LeftUpperLeg")
            local lllp, lllo = gsp("LeftLowerLeg")
            local lfp, lfo = gsp("LeftFoot")
            local rulp, rulo = gsp("RightUpperLeg")
            local rllp, rllo = gsp("RightLowerLeg")
            local rfp, rfo = gsp("RightFoot")
            if ho and uto and lto then
                ul("HeadToUpperTorso", hp, utp, ho, uto)
                ul("UpperTorsoToLowerTorso", utp, ltp, uto, lto)
                ul("UpperTorsoToLeftUpperArm", utp, luap, uto, luao)
                ul("LeftUpperArmToLeftLowerArm", luap, llap, luao, llao)
                ul("LeftLowerArmToLeftHand", llap, lhp, llao, lho)
                ul("UpperTorsoToRightUpperArm", utp, ruap, uto, ruao)
                ul("RightUpperArmToRightLowerArm", ruap, rlap, ruao, rlao)
                ul("RightLowerArmToRightHand", rlap, rhp, rlao, rho)
                ul("LowerTorsoToLeftUpperLeg", ltp, lulp, lto, lulo)
                ul("LeftUpperLegToLeftLowerLeg", lulp, lllp, lulo, lllo)
                ul("LeftLowerLegToLeftFoot", lllp, lfp, lllo, lfo)
                ul("LowerTorsoToRightUpperLeg", ltp, rulp, lto, rulo)
                ul("RightUpperLegToRightLowerLeg", rulp, rllp, rulo, rllo)
                ul("RightLowerLegToRightFoot", rllp, rfp, rllo, rfo)
            else self:HideSkeleton(op) end
        end
        sd.Initialized = true
    end
end
for p in pairs(self.Caches.SkeletonCache) do if not ap[p] then self:ClearSkeleton(p) end end
end

function espModule:UpdateTracer(dt)
if not self.State.TracerEnabled then self:ClearAllTracers() return end
if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then self:ClearAllTracers() return end


local vs = currentCamera.ViewportSize
local op2
if self.Config.TracerOrigin == "Bottom Screen" then op2 = Vector2.new(vs.X / 2, vs.Y)
elseif self.Config.TracerOrigin == "Cursor" then op2 = userInputService:GetMouseLocation()
elseif self.Config.TracerOrigin == "Top Screen" then op2 = Vector2.new(vs.X / 2, 0) end

local ap = {}
local pl = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)

for _, op in ipairs(playersService:GetPlayers()) do
    if op ~= localPlayer then
        ap[op] = true
        if not isValidTarget(self, op) then self:ClearTracer(op) continue end
        local oc = op.Character
        local tt = oc:FindFirstChild("HumanoidRootPart")
        if not tt then self:ClearTracer(op) continue end
        if not self.Caches.TracerCache[op] then self.Caches.TracerCache[op] = self:CreateTracer(op) end
        local td = self.Caches.TracerCache[op]
        local tsp, ton = currentCamera:WorldToViewportPoint(tt.Position)
        local tto = Vector2.new(tsp.X, tsp.Y)
        td.TargetFrom = op2
        td.TargetTo = tto
        if not td.Initialized then
            td.CurrentFrom = op2
            td.CurrentTo = tto
            td.Initialized = true
        else
            td.CurrentFrom = lerpVector2(td.CurrentFrom, op2, pl)
            td.CurrentTo = lerpVector2(td.CurrentTo, tto, pl)
        end
        td.Line.From = td.CurrentFrom
        td.Line.To = td.CurrentTo
        td.Line.Color = self.Config.TracerColor
        td.Line.Visible = ton
    end
end
for p in pairs(self.Caches.TracerCache) do if not ap[p] then self:ClearTracer(p) end end
end

function espModule:UpdateChams()
if not self.State.ChamsEnabled then self:ClearAllChams() return end
if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then self:ClearAllChams() return end
local ap = {}
for _, op in ipairs(playersService:GetPlayers()) do
if op ~= localPlayer then
ap[op] = true
if not isValidTarget(self, op) then self:ClearChams(op) continue end
if not self.Caches.ChamsCache[op] then
self.Caches.ChamsCache[op] = self:CreateChams(op)
else
local h = self.Caches.ChamsCache[op]
h.FillColor = self.Config.ChamsColor
h.OutlineColor = self.Config.ChamsOutlineColor
h.FillTransparency = self.Config.ChamsFillTransparency
end
end
end
for p in pairs(self.Caches.ChamsCache) do if not ap[p] then self:ClearChams(p) end end
end

function espModule:UpdateWireframe()
if not self.State.WireframeEnabled then self:ClearAllWireframes() return end
if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then self:ClearAllWireframes() return end
local ap = {}
for _, op in ipairs(playersService:GetPlayers()) do
if op ~= localPlayer then
ap[op] = true
if not isValidTarget(self, op) then self:ClearWireframe(op) continue end
local oc = op.Character
if not self.Caches.WireframeCache[op] then self.Caches.WireframeCache[op] = self:CreateWireframe(op) end
local wd = self.Caches.WireframeCache[op]
for _, pn in ipairs(BODY_PARTS) do
local pt = oc:FindFirstChild(pn)
local ls = wd.Lines[pn]
if pt and pt:IsA("BasePart") and ls then
local cs = getBoxCorners(pt)
local scs = {}
local aon = true
for i, c in ipairs(cs) do
local sp, on, d = worldToScreen(c.Position)
scs[i] = {pos = sp, onScreen = on, depth = d}
if d < 0 then aon = false end
end
if aon then
for i, e in ipairs(CUBE_EDGES) do
local l = ls[i]
local c1, c2 = scs[e[1]], scs[e[2]]
if c1.onScreen and c2.onScreen then
l.From = c1.pos
l.To = c2.pos
l.Color = self.Config.WireframeColor
l.Thickness = self.Config.WireframeThickness
l.Visible = true
else l.Visible = false end
end
else for i = 1, TOTAL_LINES do ls[i].Visible = false end end
else if ls then for i = 1, TOTAL_LINES do ls[i].Visible = false end end end
end
end
end
for p in pairs(self.Caches.WireframeCache) do if not ap[p] then self:ClearWireframe(p) end end
end

function espModule:UpdateRing()
if not self.State.RingEnabled then self:ClearAllRings() return end
if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then self:ClearAllRings() return end
local ap = {}
for _, op in ipairs(playersService:GetPlayers()) do
if op ~= localPlayer then
ap[op] = true
if not isValidTarget(self, op) then self:ClearRing(op) continue end
local oc = op.Character
local or2 = oc.HumanoidRootPart
if not self.Caches.RingCache[op] then self.Caches.RingCache[op] = self:CreateRing(op) end
local d = self.Caches.RingCache[op]
if d then
d.Root = or2
d.Ring.Color3 = self.Config.RingColor
d.Ring.Visible = true
end
end
end
for p in pairs(self.Caches.RingCache) do if not ap[p] then self:ClearRing(p) end end
end

function espModule:UpdateAnimations(dt)
local t = tick()
currentRotation = (currentRotation - self.Config.RotateSpeed * dt) % 360
for _, bd in pairs(self.Caches.BoxCache) do
if self.Config.BoxGradientEnabled and bd.Gradient then bd.Gradient.Rotation = currentRotation end
if self.State.OutlineGradientEnabled and bd.OutlineGradient then bd.OutlineGradient.Rotation = currentRotation end
end
for _, d in pairs(self.Caches.RingCache) do
if d and d.Root and d.Ring and d.Ring.Visible then
local yo = math.sin(t * self.Config.ScanSpeed) * self.Config.ScanHeight
d.Holder.CFrame = d.Root.CFrame * CFrame.new(0, yo, 0)
d.Ring.Transparency = 0.2 + (math.abs(math.sin(t * self.Config.ScanSpeed)) * 0.4)
end
end
end

function espModule:SetBoxEnabled(v) self.State.BoxEnabled = v if not v and not isAnyBoxFeatureEnabled(self) then self:ClearAllBoxes() end end
function espModule:SetNameEnabled(v) self.State.NameEnabled = v if not v and not isAnyBoxFeatureEnabled(self) then self:ClearAllBoxes() end end
function espModule:SetDistanceEnabled(v) self.State.DistanceEnabled = v if not v and not isAnyBoxFeatureEnabled(self) then self:ClearAllBoxes() end end
function espModule:SetHealthTextEnabled(v) self.State.HealthTextEnabled = v if not v and not isAnyBoxFeatureEnabled(self) then self:ClearAllBoxes() end end
function espModule:SetHealthBarEnabled(v) self.State.HealthBarEnabled = v if not v and not isAnyBoxFeatureEnabled(self) then self:ClearAllBoxes() end end
function espModule:SetArmorBarEnabled(v) self.State.ArmorBarEnabled = v if not v and not isAnyBoxFeatureEnabled(self) then self:ClearAllBoxes() end end
function espModule:SetSkeletonEnabled(v) self.State.SkeletonEnabled = v if not v then self:ClearAllSkeletons() end end
function espModule:SetTracerEnabled(v) self.State.TracerEnabled = v if not v then self:ClearAllTracers() end end
function espModule:SetChamsEnabled(v) self.State.ChamsEnabled = v if not v then self:ClearAllChams() end end
function espModule:SetWireframeEnabled(v) self.State.WireframeEnabled = v if not v then self:ClearAllWireframes() end end
function espModule:SetRingEnabled(v) self.State.RingEnabled = v if not v then self:ClearAllRings() end end
function espModule:SetHealthGradientEnabled(v) self.State.HealthGradientEnabled = v end

function espModule:InitiateBox(c) self.Config.BoxColor = c or self.Config.BoxColor self.State.BoxEnabled = true end
function espModule:InitiateName(v) self.State.NameEnabled = v end
function espModule:InitiateDistance(v) self.State.DistanceEnabled = v end
function espModule:InitiateSkeleton(c) self.Config.SkeletonColor = c or self.Config.SkeletonColor self.State.SkeletonEnabled = true end
function espModule:InitiateHealthText(v) self.State.HealthTextEnabled = v end
function espModule:InitiateHealthBar(v) self.State.HealthBarEnabled = v end
function espModule:InitiateArmorBar(v) self.State.ArmorBarEnabled = v end
function espModule:InitiateTracer(c, o) self.Config.TracerColor = c or self.Config.TracerColor self.Config.TracerOrigin = o or self.Config.TracerOrigin self.State.TracerEnabled = true end
function espModule:InitiateChams(c) self.Config.ChamsColor = c or self.Config.ChamsColor self.State.ChamsEnabled = true end
function espModule:InitiateWireframe(c) self.Config.WireframeColor = c or self.Config.WireframeColor self.State.WireframeEnabled = true end
function espModule:InitiateRing(c) self.Config.RingColor = c or self.Config.RingColor self.State.RingEnabled = true end

function espModule:TeamCheck(v) self.Config.TeamCheck = v end
function espModule:SetDistance(v) self.Config.ESPDistance = v end
function espModule:SetOutlineGradient1(c) self.Config.BoxOutlineGradient1 = c end
function espModule:SetOutlineGradient2(c) self.Config.BoxOutlineGradient2 = c end
function espModule:SetOutlineGradient3(c) self.Config.BoxOutlineGradient3 = c end
function espModule:SetFillGradient1(c) self.Config.BoxGradientColor1 = c end
function espModule:SetFillGradient2(c) self.Config.BoxGradientColor2 = c end
function espModule:SetFillGradient3(c) self.Config.BoxGradientColor3 = c end
function espModule:SetHealthGradient1(c) self.Config.HealthBarGradient1 = c self:UpdateHealthGradient() end
function espModule:SetHealthGradient2(c) self.Config.HealthBarGradient2 = c self:UpdateHealthGradient() end
function espModule:SetHealthGradient3(c) self.Config.HealthBarGradient3 = c self:UpdateHealthGradient() end

function espModule:UpdateOutlineGradient()
for _, bd in pairs(self.Caches.BoxCache) do
if bd.OutlineGradient then
bd.OutlineGradient.Color = ColorSequence.new({
ColorSequenceKeypoint.new(0, self.Config.BoxOutlineGradient1),
ColorSequenceKeypoint.new(0.5, self.Config.BoxOutlineGradient2),
ColorSequenceKeypoint.new(1, self.Config.BoxOutlineGradient3)
})
end
end
end

function espModule:UpdateFillGradient()
for _, bd in pairs(self.Caches.BoxCache) do
if bd.Gradient then
bd.Gradient.Color = ColorSequence.new({
ColorSequenceKeypoint.new(0, self.Config.BoxGradientColor1),
ColorSequenceKeypoint.new(0.5, self.Config.BoxGradientColor2),
ColorSequenceKeypoint.new(1, self.Config.BoxGradientColor3)
})
end
end
end

function espModule:UpdateHealthGradient()
for _, bd in pairs(self.Caches.BoxCache) do
if bd.HealthBarInnerGradient then
bd.HealthBarInnerGradient.Color = ColorSequence.new({
ColorSequenceKeypoint.new(0, self.Config.HealthBarGradient3),
ColorSequenceKeypoint.new(0.5, self.Config.HealthBarGradient2),
ColorSequenceKeypoint.new(1, self.Config.HealthBarGradient1)
})
end
end
end

function espModule:Cleanup()
self:ClearAllBoxes()
self:ClearAllSkeletons()
self:ClearAllTracers()
self:ClearAllChams()
self:ClearAllWireframes()
self:ClearAllRings()
end

function espModule:Destroy()
self:Cleanup()
if heartbeatConnection then heartbeatConnection:Disconnect() heartbeatConnection = nil end
if renderConnection then renderConnection:Disconnect() renderConnection = nil end
if self.EspGui then self.EspGui:Destroy() self.EspGui = nil end
self.State.BoxEnabled = false
self.State.NameEnabled = false
self.State.DistanceEnabled = false
self.State.SkeletonEnabled = false
self.State.HealthTextEnabled = false
self.State.HealthBarEnabled = false
self.State.ArmorBarEnabled = false
self.State.TracerEnabled = false
self.State.ChamsEnabled = false
self.State.WireframeEnabled = false
self.State.RingEnabled = false
end

function espModule:Initialize()
self.EspGui = Instance.new("ScreenGui")
self.EspGui.Name = "MatchaEspGui"
self.EspGui.Parent = localPlayer.PlayerGui
self.EspGui.IgnoreGuiInset = true
self.EspGui.ResetOnSpawn = false

playersService.PlayerRemoving:Connect(function(rp)
    safeCall(function()
        self:ClearBox(rp) self:ClearSkeleton(rp) self:ClearTracer(rp)
        self:ClearChams(rp) self:ClearWireframe(rp) self:ClearRing(rp)
    end)
end)

for _, p in ipairs(playersService:GetPlayers()) do
    if p ~= localPlayer then
        p.CharacterAdded:Connect(function()
            safeCall(function()
                self:ClearBox(p) self:ClearSkeleton(p) self:ClearTracer(p)
                self:ClearChams(p) self:ClearWireframe(p) self:ClearRing(p)
            end)
        end)
    end
end

playersService.PlayerAdded:Connect(function(ap)
    ap.CharacterAdded:Connect(function(nc)
        safeCall(function()
            self:ClearBox(ap) self:ClearSkeleton(ap) self:ClearTracer(ap)
            self:ClearChams(ap) self:ClearWireframe(ap) self:ClearRing(ap)
        end)
        local h = nc:WaitForChild("Humanoid", 5)
        if h then
            h.Died:Connect(function()
                safeCall(function()
                    self:ClearBox(ap) self:ClearSkeleton(ap) self:ClearTracer(ap)
                    self:ClearChams(ap) self:ClearWireframe(ap) self:ClearRing(ap)
                end)
            end)
        end
    end)
end)

renderConnection = runService.RenderStepped:Connect(function(dt)
    safeCall(function()
        self:UpdateBox(dt)
        self:UpdateSkeleton(dt)
        self:UpdateTracer(dt)
        self:UpdateChams()
        self:UpdateWireframe()
        self:UpdateRing()
        self:UpdateAnimations(dt)
    end)
end)

