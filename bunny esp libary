local playersService = game:GetService("Players")
local workspaceService = game:GetService("Workspace")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")

local espModule = {}
espModule.__index = espModule

espModule.Config = {
    TeamCheck = true,
    ESPDistance = 1000,
    BoxColor = Color3.new(0.403922, 0.34902, 0.701961),
    BoxGradientEnabled = false,
    BoxGradientColor1 = Color3.new(0.403922, 0.34902, 0.701961),
    BoxGradientColor2 = Color3.new(0.8, 0.4, 1),
    BoxFillTransparency = 0.5,
    RotateSpeed = 120,
    BoxOutlineEnabled = true,
    BoxOutlineColor = Color3.new(0, 0, 0),
    SkeletonColor = Color3.new(0.403922, 0.34902, 0.701961),
    ChamsColor = Color3.new(0.403922, 0.34902, 0.701961),
    ChamsFillTransparency = 0.5,
    ChamsOutlineColor = Color3.new(1, 1, 1),
    WireframeColor = Color3.new(0.403922, 0.34902, 0.701961),
    WireframeSurfaceColor = Color3.new(0.403922, 0.34902, 0.701961),
    WireframeTransparency = 0.8,
    WireframeSurfaceTransparency = 0.95,
    TracerOrigin = "Bottom Screen",
    TracerColor = Color3.new(0.403922, 0.34902, 0.701961),
    HealthBarLerpSpeed = 0.15,
    PositionLerpSpeed = 0.3,
    ColorLerpSpeed = 0.1,
    HealthColorFull = Color3.fromRGB(0, 255, 0),
    HealthColorMid = Color3.fromRGB(255, 255, 0),
    HealthColorLow = Color3.fromRGB(255, 0, 0),
    ArmorBarColor = Color3.fromRGB(0, 150, 255),
    RingColor = Color3.fromRGB(255, 255, 255),
    ScanSpeed = 2.5,
    ScanHeight = 3.5,
    RingRadius = 2.5
}

espModule.State = {
    BoxEnabled = false,
    NameEnabled = false,
    DistanceEnabled = false,
    SkeletonEnabled = false,
    HealthTextEnabled = false,
    HealthBarEnabled = false,
    ArmorBarEnabled = false,
    TracerEnabled = false,
    ChamsEnabled = false,
    WireframeEnabled = false,
    RingEnabled = false
}

espModule.Caches = {
    BoxCache = {},
    SkeletonCache = {},
    TracerCache = {},
    ChamsCache = {},
    WireframeCache = {},
    RingCache = {}
}

local localPlayer = playersService.LocalPlayer
local currentCamera = workspaceService.CurrentCamera
local heartbeatConnection = nil
local renderConnection = nil
local currentRotation = 0

local function safeCall(callback)
    local success, errorMessage = pcall(callback)
    if not success then
        warn("MatchaEsp Error: " .. tostring(errorMessage))
    end
end

local function lerpNumber(a, b, t)
    return a + (b - a) * math.clamp(t, 0, 1)
end

local function lerpVector2(a, b, t)
    return Vector2.new(
        lerpNumber(a.X, b.X, t),
        lerpNumber(a.Y, b.Y, t)
    )
end

local function lerpColor3(a, b, t)
    return Color3.new(
        lerpNumber(a.R, b.R, t),
        lerpNumber(a.G, b.G, t),
        lerpNumber(a.B, b.B, t)
    )
end

local function getHealthColor(healthPercent, config)
    if healthPercent > 50 then
        return config.HealthColorFull
    elseif healthPercent > 25 then
        local t = (healthPercent - 25) / 25
        return lerpColor3(config.HealthColorMid, config.HealthColorFull, t)
    else
        local t = healthPercent / 25
        return lerpColor3(config.HealthColorLow, config.HealthColorMid, t)
    end
end

local function getCameraDistance(worldPosition)
    return (currentCamera.CFrame.Position - worldPosition).Magnitude
end

local function isAnyBoxFeatureEnabled(self)
    return self.State.BoxEnabled or 
           self.State.NameEnabled or 
           self.State.DistanceEnabled or 
           self.State.HealthTextEnabled or 
           self.State.HealthBarEnabled or 
           self.State.ArmorBarEnabled
end

local function isAnyESPEnabled(self)
    return isAnyBoxFeatureEnabled(self) or
           self.State.SkeletonEnabled or
           self.State.TracerEnabled or
           self.State.ChamsEnabled or
           self.State.WireframeEnabled or
           self.State.RingEnabled
end

local function isTeammate(self, otherPlayer)
    if not self.Config.TeamCheck then return false end
    if not localPlayer.Team then return false end
    if not otherPlayer.Team then return false end
    return otherPlayer.Team == localPlayer.Team
end

local function isValidTarget(self, otherPlayer)
    if otherPlayer == localPlayer then return false end
    
    local otherCharacter = otherPlayer.Character
    if not otherCharacter then return false end
    
    local otherRoot = otherCharacter:FindFirstChild("HumanoidRootPart")
    if not otherRoot then return false end
    
    local otherHumanoid = otherCharacter:FindFirstChild("Humanoid")
    if not otherHumanoid then return false end
    if otherHumanoid.Health <= 0 then return false end
    
    local distance = getCameraDistance(otherRoot.Position)
    if distance > self.Config.ESPDistance then return false end
    
    if isTeammate(self, otherPlayer) then return false end
    
    return true
end

function espModule:CreateBox(_)
    local boxDrawings = {
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthText = Drawing.new("Text"),
        HealthBarBackground = Drawing.new("Square"),
        HealthBar = Drawing.new("Square"),
        HealthBarOutline = Drawing.new("Square"),
        ArmorText = Drawing.new("Text"),
        ArmorBarBackground = Drawing.new("Square"),
        ArmorBar = Drawing.new("Square"),
        ArmorBarOutline = Drawing.new("Square"),
        FillFrame = Instance.new("Frame"),
        Gradient = Instance.new("UIGradient"),
        Stroke = Instance.new("UIStroke"),
        CurrentHealth = 100,
        TargetHealth = 100,
        CurrentArmor = 0,
        TargetArmor = 0,
        CurrentHealthColor = self.Config.HealthColorFull,
        TargetHealthColor = self.Config.HealthColorFull,
        CurrentPosition = Vector2.new(0, 0),
        TargetPosition = Vector2.new(0, 0),
        CurrentSize = Vector2.new(0, 0),
        TargetSize = Vector2.new(0, 0),
        Initialized = false
    }
    
    boxDrawings.FillFrame.Parent = self.EspGui
    boxDrawings.FillFrame.BorderSizePixel = 0
    boxDrawings.FillFrame.BackgroundTransparency = 1
    boxDrawings.FillFrame.Visible = false
    boxDrawings.Gradient.Parent = boxDrawings.FillFrame
    boxDrawings.Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, self.Config.BoxGradientColor1),
        ColorSequenceKeypoint.new(0.5, self.Config.BoxGradientColor2),
        ColorSequenceKeypoint.new(1, self.Config.BoxGradientColor1)
    })
    boxDrawings.Stroke.Parent = boxDrawings.FillFrame
    boxDrawings.Stroke.Thickness = 1.2
    boxDrawings.Stroke.Color = self.Config.BoxOutlineColor
    boxDrawings.Stroke.Transparency = 0
    boxDrawings.Stroke.Enabled = self.Config.BoxOutlineEnabled
    
    boxDrawings.Box.Thickness = 1
    boxDrawings.Box.Color = self.Config.BoxColor
    boxDrawings.Box.Filled = false
    boxDrawings.Box.Visible = false
    boxDrawings.Box.Transparency = 1
    
    boxDrawings.BoxOutline.Thickness = 3
    boxDrawings.BoxOutline.Color = self.Config.BoxOutlineColor
    boxDrawings.BoxOutline.Filled = false
    boxDrawings.BoxOutline.Visible = false
    boxDrawings.BoxOutline.Transparency = 1
    
    boxDrawings.Name.Size = 14
    boxDrawings.Name.Color = Color3.new(1, 1, 1)
    boxDrawings.Name.Outline = true
    boxDrawings.Name.OutlineColor = Color3.new(0, 0, 0)
    boxDrawings.Name.Center = true
    boxDrawings.Name.Visible = false
    boxDrawings.Name.Font = 2
    boxDrawings.Name.Transparency = 1
    
    boxDrawings.Distance.Size = 13
    boxDrawings.Distance.Color = Color3.fromRGB(200, 200, 200)
    boxDrawings.Distance.Outline = true
    boxDrawings.Distance.OutlineColor = Color3.new(0, 0, 0)
    boxDrawings.Distance.Center = true
    boxDrawings.Distance.Visible = false
    boxDrawings.Distance.Font = 2
    boxDrawings.Distance.Transparency = 1
    
    boxDrawings.HealthText.Size = 12
    boxDrawings.HealthText.Color = Color3.new(1, 1, 1)
    boxDrawings.HealthText.Outline = true
    boxDrawings.HealthText.OutlineColor = Color3.new(0, 0, 0)
    boxDrawings.HealthText.Center = false
    boxDrawings.HealthText.Visible = false
    boxDrawings.HealthText.Font = 2
    boxDrawings.HealthText.Transparency = 1
    
    boxDrawings.HealthBarBackground.Thickness = 1
    boxDrawings.HealthBarBackground.Color = Color3.fromRGB(30, 30, 30)
    boxDrawings.HealthBarBackground.Filled = true
    boxDrawings.HealthBarBackground.Visible = false
    boxDrawings.HealthBarBackground.Transparency = 0.3
    
    boxDrawings.HealthBarOutline.Thickness = 1
    boxDrawings.HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
    boxDrawings.HealthBarOutline.Filled = false
    boxDrawings.HealthBarOutline.Visible = false
    boxDrawings.HealthBarOutline.Transparency = 1
    
    boxDrawings.HealthBar.Thickness = 1
    boxDrawings.HealthBar.Color = self.Config.HealthColorFull
    boxDrawings.HealthBar.Filled = true
    boxDrawings.HealthBar.Visible = false
    boxDrawings.HealthBar.Transparency = 1
    
    boxDrawings.ArmorText.Size = 12
    boxDrawings.ArmorText.Color = self.Config.ArmorBarColor
    boxDrawings.ArmorText.Outline = true
    boxDrawings.ArmorText.OutlineColor = Color3.new(0, 0, 0)
    boxDrawings.ArmorText.Center = false
    boxDrawings.ArmorText.Visible = false
    boxDrawings.ArmorText.Font = 2
    boxDrawings.ArmorText.Transparency = 1
    
    boxDrawings.ArmorBarBackground.Thickness = 1
    boxDrawings.ArmorBarBackground.Color = Color3.fromRGB(30, 30, 30)
    boxDrawings.ArmorBarBackground.Filled = true
    boxDrawings.ArmorBarBackground.Visible = false
    boxDrawings.ArmorBarBackground.Transparency = 0.3
    
    boxDrawings.ArmorBarOutline.Thickness = 1
    boxDrawings.ArmorBarOutline.Color = Color3.fromRGB(0, 0, 0)
    boxDrawings.ArmorBarOutline.Filled = false
    boxDrawings.ArmorBarOutline.Visible = false
    boxDrawings.ArmorBarOutline.Transparency = 1
    
    boxDrawings.ArmorBar.Thickness = 1
    boxDrawings.ArmorBar.Color = self.Config.ArmorBarColor
    boxDrawings.ArmorBar.Filled = true
    boxDrawings.ArmorBar.Visible = false
    boxDrawings.ArmorBar.Transparency = 1
    
    return boxDrawings
end

function espModule:CreateSkeleton(targetPlayer)
    local targetCharacter = targetPlayer.Character
    local isR6 = targetCharacter and targetCharacter:FindFirstChild("Torso") and not targetCharacter:FindFirstChild("UpperTorso")
    
    local skeletonData = {
        IsR6 = isR6,
        Lines = {},
        CurrentPositions = {},
        TargetPositions = {}
    }
    
    if isR6 then
        local lineNames = {"HeadToTorso", "TorsoToLeftArm", "TorsoToRightArm", "TorsoToLeftLeg", "TorsoToRightLeg"}
        for _, name in ipairs(lineNames) do
            local line = Drawing.new("Line")
            line.Thickness = 2
            line.Color = self.Config.SkeletonColor
            line.Visible = false
            line.Transparency = 1
            skeletonData.Lines[name] = line
            skeletonData.CurrentPositions[name .. "From"] = Vector2.new(0, 0)
            skeletonData.CurrentPositions[name .. "To"] = Vector2.new(0, 0)
            skeletonData.TargetPositions[name .. "From"] = Vector2.new(0, 0)
            skeletonData.TargetPositions[name .. "To"] = Vector2.new(0, 0)
        end
    else
        local lineNames = {
            "HeadToUpperTorso", "UpperTorsoToLowerTorso",
            "UpperTorsoToLeftUpperArm", "LeftUpperArmToLeftLowerArm", "LeftLowerArmToLeftHand",
            "UpperTorsoToRightUpperArm", "RightUpperArmToRightLowerArm", "RightLowerArmToRightHand",
            "LowerTorsoToLeftUpperLeg", "LeftUpperLegToLeftLowerLeg", "LeftLowerLegToLeftFoot",
            "LowerTorsoToRightUpperLeg", "RightUpperLegToRightLowerLeg", "RightLowerLegToRightFoot"
        }
        for _, name in ipairs(lineNames) do
            local line = Drawing.new("Line")
            line.Thickness = 2
            line.Color = self.Config.SkeletonColor
            line.Visible = false
            line.Transparency = 1
            skeletonData.Lines[name] = line
            skeletonData.CurrentPositions[name .. "From"] = Vector2.new(0, 0)
            skeletonData.CurrentPositions[name .. "To"] = Vector2.new(0, 0)
            skeletonData.TargetPositions[name .. "From"] = Vector2.new(0, 0)
            skeletonData.TargetPositions[name .. "To"] = Vector2.new(0, 0)
        end
    end
    
    skeletonData.Initialized = false
    return skeletonData
end

function espModule:CreateTracer(_)
    local tracerData = {
        Line = Drawing.new("Line"),
        CurrentFrom = Vector2.new(0, 0),
        CurrentTo = Vector2.new(0, 0),
        TargetFrom = Vector2.new(0, 0),
        TargetTo = Vector2.new(0, 0),
        Initialized = false
    }
    
    tracerData.Line.Thickness = 1.5
    tracerData.Line.Color = self.Config.TracerColor
    tracerData.Line.Visible = false
    tracerData.Line.Transparency = 1
    
    return tracerData
end

function espModule:CreateChams(targetPlayer)
    local highlight = Instance.new("Highlight")
    highlight.FillColor = self.Config.ChamsColor
    highlight.OutlineColor = self.Config.ChamsOutlineColor
    highlight.FillTransparency = self.Config.ChamsFillTransparency
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = targetPlayer.Character
    highlight.Adornee = targetPlayer.Character
    return highlight
end

function espModule:CreateWireframe(targetPlayer)
    local character = targetPlayer.Character
    if not character then return nil end
    
    local wireframeData = {
        Boxes = {},
        SurfaceGuis = {},
        Character = character
    }
    
    local bodyParts = {
        "Head", "Torso", "UpperTorso", "LowerTorso",
        "Left Arm", "Right Arm", "LeftUpperArm", "LeftLowerArm", "LeftHand",
        "RightUpperArm", "RightLowerArm", "RightHand",
        "Left Leg", "Right Leg", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
        "RightUpperLeg", "RightLowerLeg", "RightFoot", "HumanoidRootPart"
    }
    
    for _, partName in ipairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            local box = Instance.new("BoxHandleAdornment")
            box.Name = "WireframeBox_" .. partName
            box.Adornee = part
            box.AlwaysOnTop = true
            box.ZIndex = 5
            box.Size = part.Size + Vector3.new(0.05, 0.05, 0.05)
            box.Color3 = self.Config.WireframeColor
            box.Transparency = self.Config.WireframeTransparency
            box.Parent = part
            wireframeData.Boxes[partName] = box
            
            local faces = {
                Enum.NormalId.Front,
                Enum.NormalId.Back,
                Enum.NormalId.Left,
                Enum.NormalId.Right,
                Enum.NormalId.Top,
                Enum.NormalId.Bottom
            }
            
            wireframeData.SurfaceGuis[partName] = {}
            
            for _, face in ipairs(faces) do
                local surfaceGui = Instance.new("SurfaceGui")
                surfaceGui.Name = "WireframeSurface_" .. tostring(face)
                surfaceGui.Face = face
                surfaceGui.Adornee = part
                surfaceGui.AlwaysOnTop = true
                surfaceGui.LightInfluence = 0
                surfaceGui.ResetOnSpawn = false
                surfaceGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                
                local frame = Instance.new("Frame")
                frame.Name = "WireframeFrame"
                frame.Size = UDim2.new(1, 0, 1, 0)
                frame.BackgroundColor3 = self.Config.WireframeSurfaceColor
                frame.BackgroundTransparency = self.Config.WireframeSurfaceTransparency
                frame.BorderSizePixel = 0
                frame.Parent = surfaceGui
                
                local stroke = Instance.new("UIStroke")
                stroke.Color = self.Config.WireframeColor
                stroke.Thickness = 2
                stroke.Transparency = self.Config.WireframeTransparency
                stroke.Parent = frame
                
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, 2)
                corner.Parent = frame
                
                surfaceGui.Parent = part
                table.insert(wireframeData.SurfaceGuis[partName], surfaceGui)
            end
        end
    end
    
    return wireframeData
end

function espModule:CreateRing(player)
    if player == localPlayer then return nil end
    local holder = Instance.new("Part")
    holder.Name = "ESP_Holder_" .. player.Name
    holder.Transparency = 1
    holder.CanCollide = false
    holder.Anchored = true
    holder.Parent = workspace
    local ring = Instance.new("CylinderHandleAdornment")
    ring.Adornee = holder
    ring.AlwaysOnTop = true
    ring.ZIndex = 10
    ring.Color3 = self.Config.RingColor
    ring.InnerRadius = self.Config.RingRadius - 0.1
    ring.Radius = self.Config.RingRadius
    ring.Height = 0.08
    ring.CFrame = CFrame.Angles(math.rad(90), 0, 0)
    ring.Parent = holder
    ring.Visible = false
    return {Holder = holder, Ring = ring, Root = nil}
end

function espModule:ClearBox(targetPlayer)
    local cache = self.Caches.BoxCache[targetPlayer]
    if cache then
        pcall(function() cache.Box:Remove() end)
        pcall(function() cache.BoxOutline:Remove() end)
        pcall(function() cache.Name:Remove() end)
        pcall(function() cache.Distance:Remove() end)
        pcall(function() cache.HealthText:Remove() end)
        pcall(function() cache.HealthBarBackground:Remove() end)
        pcall(function() cache.HealthBar:Remove() end)
        pcall(function() cache.HealthBarOutline:Remove() end)
        pcall(function() cache.ArmorText:Remove() end)
        pcall(function() cache.ArmorBarBackground:Remove() end)
        pcall(function() cache.ArmorBar:Remove() end)
        pcall(function() cache.ArmorBarOutline:Remove() end)
        pcall(function() cache.FillFrame:Destroy() end)
        self.Caches.BoxCache[targetPlayer] = nil
    end
end

function espModule:ClearSkeleton(targetPlayer)
    local cache = self.Caches.SkeletonCache[targetPlayer]
    if cache then
        for _, line in pairs(cache.Lines) do
            pcall(function() line:Remove() end)
        end
        self.Caches.SkeletonCache[targetPlayer] = nil
    end
end

function espModule:ClearTracer(targetPlayer)
    local cache = self.Caches.TracerCache[targetPlayer]
    if cache then
        pcall(function() cache.Line:Remove() end)
        self.Caches.TracerCache[targetPlayer] = nil
    end
end

function espModule:ClearChams(targetPlayer)
    local cache = self.Caches.ChamsCache[targetPlayer]
    if cache then
        pcall(function() cache:Destroy() end)
        self.Caches.ChamsCache[targetPlayer] = nil
    end
end

function espModule:ClearWireframe(targetPlayer)
    local cache = self.Caches.WireframeCache[targetPlayer]
    if cache then
        for _, box in pairs(cache.Boxes) do
            pcall(function() box:Destroy() end)
        end
        for _, guiTable in pairs(cache.SurfaceGuis) do
            for _, gui in ipairs(guiTable) do
                pcall(function() gui:Destroy() end)
            end
        end
        self.Caches.WireframeCache[targetPlayer] = nil
    end
end

function espModule:ClearRing(targetPlayer)
    local cache = self.Caches.RingCache[targetPlayer]
    if cache then
        pcall(function() cache.Holder:Destroy() end)
        self.Caches.RingCache[targetPlayer] = nil
    end
end

function espModule:ClearAllBoxes()
    for player, _ in pairs(self.Caches.BoxCache) do
        self:ClearBox(player)
    end
end

function espModule:ClearAllSkeletons()
    for player, _ in pairs(self.Caches.SkeletonCache) do
        self:ClearSkeleton(player)
    end
end

function espModule:ClearAllTracers()
    for player, _ in pairs(self.Caches.TracerCache) do
        self:ClearTracer(player)
    end
end

function espModule:ClearAllChams()
    for player, _ in pairs(self.Caches.ChamsCache) do
        self:ClearChams(player)
    end
end

function espModule:ClearAllWireframes()
    for player, _ in pairs(self.Caches.WireframeCache) do
        self:ClearWireframe(player)
    end
end

function espModule:ClearAllRings()
    for player, _ in pairs(self.Caches.RingCache) do
        self:ClearRing(player)
    end
end

function espModule:HideBox(targetPlayer)
    local boxDrawings = self.Caches.BoxCache[targetPlayer]
    if boxDrawings then
        boxDrawings.Box.Visible = false
        boxDrawings.BoxOutline.Visible = false
        boxDrawings.FillFrame.Visible = false
        boxDrawings.Name.Visible = false
        boxDrawings.Distance.Visible = false
        boxDrawings.HealthText.Visible = false
        boxDrawings.HealthBar.Visible = false
        boxDrawings.HealthBarBackground.Visible = false
        boxDrawings.HealthBarOutline.Visible = false
        boxDrawings.ArmorText.Visible = false
        boxDrawings.ArmorBar.Visible = false
        boxDrawings.ArmorBarBackground.Visible = false
        boxDrawings.ArmorBarOutline.Visible = false
        if boxDrawings.Stroke then boxDrawings.Stroke.Enabled = false end
    end
end

function espModule:HideSkeleton(targetPlayer)
    local cache = self.Caches.SkeletonCache[targetPlayer]
    if cache then
        for _, line in pairs(cache.Lines) do
            line.Visible = false
        end
    end
end

function espModule:HideTracer(targetPlayer)
    local cache = self.Caches.TracerCache[targetPlayer]
    if cache then
        cache.Line.Visible = false
    end
end

function espModule:HideRing(targetPlayer)
    local cache = self.Caches.RingCache[targetPlayer]
    if cache and cache.Ring then
        cache.Ring.Visible = false
    end
end

function espModule:UpdateBox(dt)
    if not self or not self.State or not self.Config or not self.Caches then return end
    
    local shouldDraw = isAnyBoxFeatureEnabled(self)
    
    if not shouldDraw then
        self:ClearAllBoxes()
        return
    end
    
    if not localPlayer.Character then
        self:ClearAllBoxes()
        return
    end
    
    local localRoot = localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not localRoot then
        self:ClearAllBoxes()
        return
    end

    local cameraPos = currentCamera.CFrame.Position
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    local colorLerp = math.clamp(self.Config.ColorLerpSpeed * dt * 60, 0, 1)
    local healthLerp = math.clamp(self.Config.HealthBarLerpSpeed * dt * 60, 0, 1)

    for _, otherPlayer in ipairs(playersService:GetPlayers()) do
        if otherPlayer ~= localPlayer then
            activePlayers[otherPlayer] = true
            
            local success, err = pcall(function()
                if not isValidTarget(self, otherPlayer) then
                    self:ClearBox(otherPlayer)
                    return
                end
                
                local otherCharacter = otherPlayer.Character
                local otherRoot = otherCharacter:FindFirstChild("HumanoidRootPart")
                local otherHumanoid = otherCharacter:FindFirstChild("Humanoid")
                local distance = getCameraDistance(otherRoot.Position)
                
                if not self.Caches.BoxCache[otherPlayer] then
                    self.Caches.BoxCache[otherPlayer] = self:CreateBox(otherPlayer)
                end

                local boxDrawings = self.Caches.BoxCache[otherPlayer]
                local rootScreenPos, rootOnScreen = currentCamera:WorldToViewportPoint(otherRoot.Position)

                if not rootOnScreen then
                    self:HideBox(otherPlayer)
                    return
                end
                
                local headPart = otherCharacter:FindFirstChild("Head")
                local headTopPos = (headPart and headPart.Position + Vector3.new(0, 0.8, 0)) or (otherRoot.Position + Vector3.new(0, 2.5, 0))
                local feetPos = otherRoot.Position - Vector3.new(0, 3, 0)

                local headTopScreenPos = currentCamera:WorldToViewportPoint(headTopPos)
                local feetScreenPos = currentCamera:WorldToViewportPoint(feetPos)

                local height = math.abs(headTopScreenPos.Y - feetScreenPos.Y)
                local width = height * 0.55
                
                local centerPos = Vector2.new(rootScreenPos.X, (headTopScreenPos.Y + feetScreenPos.Y) / 2)
                local targetTopLeft = centerPos - Vector2.new(width / 2, height / 2)
                local targetSize = Vector2.new(width, height)
                
                if not boxDrawings.Initialized then
                    boxDrawings.CurrentPosition = targetTopLeft
                    boxDrawings.CurrentSize = targetSize
                    boxDrawings.Initialized = true
                else
                    boxDrawings.CurrentPosition = lerpVector2(boxDrawings.CurrentPosition, targetTopLeft, posLerp)
                    boxDrawings.CurrentSize = lerpVector2(boxDrawings.CurrentSize, targetSize, posLerp)
                end
                
                local smoothTopLeft = boxDrawings.CurrentPosition
                local smoothSize = boxDrawings.CurrentSize
                local smoothWidth = smoothSize.X
                local smoothHeight = smoothSize.Y
                local smoothCenterX = smoothTopLeft.X + smoothWidth / 2
                
                local currentHealthVal = otherHumanoid.Health
                local maxHealthVal = otherHumanoid.MaxHealth
                local healthPercent = (currentHealthVal / maxHealthVal) * 100
                
                boxDrawings.TargetHealth = healthPercent
                boxDrawings.CurrentHealth = lerpNumber(boxDrawings.CurrentHealth, boxDrawings.TargetHealth, healthLerp)
                
                local targetHealthColor = getHealthColor(boxDrawings.CurrentHealth, self.Config)
                boxDrawings.CurrentHealthColor = lerpColor3(boxDrawings.CurrentHealthColor, targetHealthColor, colorLerp)
                
                if self.State.BoxEnabled then
                    boxDrawings.Box.Visible = false
                    boxDrawings.BoxOutline.Visible = false
                    boxDrawings.FillFrame.Visible = false

                    if self.Config.BoxGradientEnabled then
                        boxDrawings.FillFrame.Position = UDim2.fromOffset(smoothTopLeft.X, smoothTopLeft.Y)
                        boxDrawings.FillFrame.Size = UDim2.fromOffset(smoothWidth, smoothHeight)
                        boxDrawings.FillFrame.BackgroundTransparency = self.Config.BoxFillTransparency
                        boxDrawings.FillFrame.Visible = true
                        boxDrawings.Stroke.Enabled = self.Config.BoxOutlineEnabled
                        boxDrawings.Stroke.Color = self.Config.BoxOutlineColor
                    else
                        if self.Config.BoxOutlineEnabled then
                            boxDrawings.BoxOutline.Size = Vector2.new(smoothWidth, smoothHeight)
                            boxDrawings.BoxOutline.Position = smoothTopLeft
                            boxDrawings.BoxOutline.Color = self.Config.BoxOutlineColor
                            boxDrawings.BoxOutline.Visible = true
                        end
                        
                        boxDrawings.Box.Size = Vector2.new(smoothWidth, smoothHeight)
                        boxDrawings.Box.Position = smoothTopLeft
                        boxDrawings.Box.Color = self.Config.BoxColor
                        boxDrawings.Box.Visible = true
                    end
                else
                    boxDrawings.Box.Visible = false
                    boxDrawings.BoxOutline.Visible = false
                    boxDrawings.FillFrame.Visible = false
                    if boxDrawings.Stroke then boxDrawings.Stroke.Enabled = false end
                end

                if self.State.NameEnabled then
                    boxDrawings.Name.Position = Vector2.new(smoothCenterX, smoothTopLeft.Y - 18)
                    boxDrawings.Name.Text = otherPlayer.Name
                    boxDrawings.Name.Visible = true
                else
                    boxDrawings.Name.Visible = false
                end

                if self.State.DistanceEnabled then
                    boxDrawings.Distance.Position = Vector2.new(smoothCenterX, smoothTopLeft.Y + smoothHeight + 3)
                    boxDrawings.Distance.Text = math.floor(distance) .. "m"
                    boxDrawings.Distance.Visible = true
                else
                    boxDrawings.Distance.Visible = false
                end

                local barX = smoothTopLeft.X - 6
                local barY = smoothTopLeft.Y

                if self.State.HealthBarEnabled or self.State.HealthTextEnabled then
                    local displayHealth = math.floor(boxDrawings.CurrentHealth)
                    
                    if self.State.HealthTextEnabled then
                        local textY = barY + smoothHeight * (1 - boxDrawings.CurrentHealth / 100)
                        textY = math.clamp(textY, barY, barY + smoothHeight - 10)
                        
                        boxDrawings.HealthText.Position = Vector2.new(barX - 18, textY - 6)
                        boxDrawings.HealthText.Text = tostring(displayHealth)
                        boxDrawings.HealthText.Color = boxDrawings.CurrentHealthColor
                        boxDrawings.HealthText.Visible = true
                    else
                        boxDrawings.HealthText.Visible = false
                    end

                    if self.State.HealthBarEnabled then
                        local barHeight = smoothHeight * (boxDrawings.CurrentHealth / 100)
                        
                        boxDrawings.HealthBarOutline.Size = Vector2.new(4, smoothHeight + 2)
                        boxDrawings.HealthBarOutline.Position = Vector2.new(barX - 1, barY - 1)
                        boxDrawings.HealthBarOutline.Visible = true
                        
                        boxDrawings.HealthBarBackground.Size = Vector2.new(2, smoothHeight)
                        boxDrawings.HealthBarBackground.Position = Vector2.new(barX, barY)
                        boxDrawings.HealthBarBackground.Visible = true
                        
                        boxDrawings.HealthBar.Size = Vector2.new(2, barHeight)
                        boxDrawings.HealthBar.Position = Vector2.new(barX, barY + smoothHeight - barHeight)
                        boxDrawings.HealthBar.Color = boxDrawings.CurrentHealthColor
                        boxDrawings.HealthBar.Visible = true
                    else
                        boxDrawings.HealthBar.Visible = false
                        boxDrawings.HealthBarBackground.Visible = false
                        boxDrawings.HealthBarOutline.Visible = false
                    end
                else
                    boxDrawings.HealthText.Visible = false
                    boxDrawings.HealthBar.Visible = false
                    boxDrawings.HealthBarBackground.Visible = false
                    boxDrawings.HealthBarOutline.Visible = false
                end

                if self.State.ArmorBarEnabled then
                    local bodyEffects = otherCharacter:FindFirstChild("BodyEffects")
                    local armorVal = (bodyEffects and bodyEffects:FindFirstChild("Armor")) and bodyEffects.Armor.Value or 0
                    local armorPercent = math.clamp((armorVal / 200) * 100, 0, 100)
                    
                    boxDrawings.TargetArmor = armorPercent
                    boxDrawings.CurrentArmor = lerpNumber(boxDrawings.CurrentArmor, boxDrawings.TargetArmor, healthLerp)

                    local armorBarX = smoothTopLeft.X + smoothWidth + 2
                    local armorBarHeight = smoothHeight * (boxDrawings.CurrentArmor / 100)
                    
                    boxDrawings.ArmorBarOutline.Size = Vector2.new(4, smoothHeight + 2)
                    boxDrawings.ArmorBarOutline.Position = Vector2.new(armorBarX - 1, barY - 1)
                    boxDrawings.ArmorBarOutline.Visible = true
                    
                    boxDrawings.ArmorBarBackground.Size = Vector2.new(2, smoothHeight)
                    boxDrawings.ArmorBarBackground.Position = Vector2.new(armorBarX, barY)
                    boxDrawings.ArmorBarBackground.Visible = true
                    
                    boxDrawings.ArmorBar.Size = Vector2.new(2, armorBarHeight)
                    boxDrawings.ArmorBar.Position = Vector2.new(armorBarX, barY + smoothHeight - armorBarHeight)
                    boxDrawings.ArmorBar.Color = self.Config.ArmorBarColor
                    boxDrawings.ArmorBar.Visible = boxDrawings.CurrentArmor > 0
                    
                    if self.State.HealthTextEnabled and boxDrawings.CurrentArmor > 0 then
                        local armorTextY = barY + smoothHeight * (1 - boxDrawings.CurrentArmor / 100)
                        armorTextY = math.clamp(armorTextY, barY, barY + smoothHeight - 10)
                        
                        boxDrawings.ArmorText.Position = Vector2.new(armorBarX + 6, armorTextY - 6)
                        boxDrawings.ArmorText.Text = tostring(math.floor(boxDrawings.CurrentArmor))
                        boxDrawings.ArmorText.Color = self.Config.ArmorBarColor
                        boxDrawings.ArmorText.Visible = true
                    else
                        boxDrawings.ArmorText.Visible = false
                    end
                else
                    boxDrawings.ArmorBar.Visible = false
                    boxDrawings.ArmorBarBackground.Visible = false
                    boxDrawings.ArmorBarOutline.Visible = false
                    boxDrawings.ArmorText.Visible = false
                end
            end)
            
            if not success then
                self:ClearBox(otherPlayer)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.BoxCache) do
        if not activePlayers[player] then
            self:ClearBox(player)
        end
    end
end

function espModule:UpdateSkeleton(dt)
    if not self.State.SkeletonEnabled then
        self:ClearAllSkeletons()
        return
    end
    
    if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        self:ClearAllSkeletons()
        return
    end
    
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    
    for _, otherPlayer in ipairs(playersService:GetPlayers()) do
        if otherPlayer ~= localPlayer then
            activePlayers[otherPlayer] = true
            
            if not isValidTarget(self, otherPlayer) then
                self:ClearSkeleton(otherPlayer)
                continue
            end
            
            local otherCharacter = otherPlayer.Character
            
            if not self.Caches.SkeletonCache[otherPlayer] then
                self.Caches.SkeletonCache[otherPlayer] = self:CreateSkeleton(otherPlayer)
            end
            
            local skeletonData = self.Caches.SkeletonCache[otherPlayer]
            local isR6 = skeletonData.IsR6
            
            local function getScreenPos(partName)
                local part = otherCharacter:FindFirstChild(partName)
                if part then
                    local screenPos, onScreen = currentCamera:WorldToViewportPoint(part.Position)
                    return Vector2.new(screenPos.X, screenPos.Y), onScreen
                end
                return Vector2.new(0, 0), false
            end
            
            local function updateLine(lineName, fromPos, toPos, fromOn, toOn)
                local line = skeletonData.Lines[lineName]
                if not line then return end
                
                local fromKey = lineName .. "From"
                local toKey = lineName .. "To"
                
                skeletonData.TargetPositions[fromKey] = fromPos
                skeletonData.TargetPositions[toKey] = toPos
                
                if not skeletonData.Initialized then
                    skeletonData.CurrentPositions[fromKey] = fromPos
                    skeletonData.CurrentPositions[toKey] = toPos
                else
                    skeletonData.CurrentPositions[fromKey] = lerpVector2(skeletonData.CurrentPositions[fromKey], fromPos, posLerp)
                    skeletonData.CurrentPositions[toKey] = lerpVector2(skeletonData.CurrentPositions[toKey], toPos, posLerp)
                end
                
                line.From = skeletonData.CurrentPositions[fromKey]
                line.To = skeletonData.CurrentPositions[toKey]
                line.Color = self.Config.SkeletonColor
                line.Visible = fromOn and toOn
            end
            
            local allOnScreen = true
            
            if isR6 then
                local headPos, headOn = getScreenPos("Head")
                local torsoPos, torsoOn = getScreenPos("Torso")
                local leftArmPos, leftArmOn = getScreenPos("Left Arm")
                local rightArmPos, rightArmOn = getScreenPos("Right Arm")
                local leftLegPos, leftLegOn = getScreenPos("Left Leg")
                local rightLegPos, rightLegOn = getScreenPos("Right Leg")
                
                allOnScreen = headOn and torsoOn
                
                if allOnScreen then
                    updateLine("HeadToTorso", headPos, torsoPos, headOn, torsoOn)
                    updateLine("TorsoToLeftArm", torsoPos, leftArmPos, torsoOn, leftArmOn)
                    updateLine("TorsoToRightArm", torsoPos, rightArmPos, torsoOn, rightArmOn)
                    updateLine("TorsoToLeftLeg", torsoPos, leftLegPos, torsoOn, leftLegOn)
                    updateLine("TorsoToRightLeg", torsoPos, rightLegPos, torsoOn, rightLegOn)
                else
                    self:HideSkeleton(otherPlayer)
                end
            else
                local headPos, headOn = getScreenPos("Head")
                local upperTorsoPos, upperTorsoOn = getScreenPos("UpperTorso")
                local lowerTorsoPos, lowerTorsoOn = getScreenPos("LowerTorso")
                local leftUpperArmPos, leftUpperArmOn = getScreenPos("LeftUpperArm")
                local leftLowerArmPos, leftLowerArmOn = getScreenPos("LeftLowerArm")
                local leftHandPos, leftHandOn = getScreenPos("LeftHand")
                local rightUpperArmPos, rightUpperArmOn = getScreenPos("RightUpperArm")
                local rightLowerArmPos, rightLowerArmOn = getScreenPos("RightLowerArm")
                local rightHandPos, rightHandOn = getScreenPos("RightHand")
                local leftUpperLegPos, leftUpperLegOn = getScreenPos("LeftUpperLeg")
                local leftLowerLegPos, leftLowerLegOn = getScreenPos("LeftLowerLeg")
                local leftFootPos, leftFootOn = getScreenPos("LeftFoot")
                local rightUpperLegPos, rightUpperLegOn = getScreenPos("RightUpperLeg")
                local rightLowerLegPos, rightLowerLegOn = getScreenPos("RightLowerLeg")
                local rightFootPos, rightFootOn = getScreenPos("RightFoot")
                
                allOnScreen = headOn and upperTorsoOn and lowerTorsoOn
                
                if allOnScreen then
                    updateLine("HeadToUpperTorso", headPos, upperTorsoPos, headOn, upperTorsoOn)
                    updateLine("UpperTorsoToLowerTorso", upperTorsoPos, lowerTorsoPos, upperTorsoOn, lowerTorsoOn)
                    updateLine("UpperTorsoToLeftUpperArm", upperTorsoPos, leftUpperArmPos, upperTorsoOn, leftUpperArmOn)
                    updateLine("LeftUpperArmToLeftLowerArm", leftUpperArmPos, leftLowerArmPos, leftUpperArmOn, leftLowerArmOn)
                    updateLine("LeftLowerArmToLeftHand", leftLowerArmPos, leftHandPos, leftLowerArmOn, leftHandOn)
                    updateLine("UpperTorsoToRightUpperArm", upperTorsoPos, rightUpperArmPos, upperTorsoOn, rightUpperArmOn)
                    updateLine("RightUpperArmToRightLowerArm", rightUpperArmPos, rightLowerArmPos, rightUpperArmOn, rightLowerArmOn)
                    updateLine("RightLowerArmToRightHand", rightLowerArmPos, rightHandPos, rightLowerArmOn, rightHandOn)
                    updateLine("LowerTorsoToLeftUpperLeg", lowerTorsoPos, leftUpperLegPos, lowerTorsoOn, leftUpperLegOn)
                    updateLine("LeftUpperLegToLeftLowerLeg", leftUpperLegPos, leftLowerLegPos, leftUpperLegOn, leftLowerLegOn)
                    updateLine("LeftLowerLegToLeftFoot", leftLowerLegPos, leftFootPos, leftLowerLegOn, leftFootOn)
                    updateLine("LowerTorsoToRightUpperLeg", lowerTorsoPos, rightUpperLegPos, lowerTorsoOn, rightUpperLegOn)
                    updateLine("RightUpperLegToRightLowerLeg", rightUpperLegPos, rightLowerLegPos, rightUpperLegOn, rightLowerLegOn)
                    updateLine("RightLowerLegToRightFoot", rightLowerLegPos, rightFootPos, rightLowerLegOn, rightFootOn)
                else
                    self:HideSkeleton(otherPlayer)
                end
            end
            
            skeletonData.Initialized = true
        end
    end
    
    for player, _ in pairs(self.Caches.SkeletonCache) do
        if not activePlayers[player] then
            self:ClearSkeleton(player)
        end
    end
end

function espModule:UpdateTracer(dt)
    if not self.State.TracerEnabled then
        self:ClearAllTracers()
        return
    end
    
    if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        self:ClearAllTracers()
        return
    end
    
    local viewportSize = currentCamera.ViewportSize
    local originPos
    
    if self.Config.TracerOrigin == "Bottom Screen" then
        originPos = Vector2.new(viewportSize.X / 2, viewportSize.Y)
    elseif self.Config.TracerOrigin == "Cursor" then
        originPos = userInputService:GetMouseLocation()
    elseif self.Config.TracerOrigin == "Top Screen" then
        originPos = Vector2.new(viewportSize.X / 2, 0)
    end
    
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    
    for _, otherPlayer in ipairs(playersService:GetPlayers()) do
        if otherPlayer ~= localPlayer then
            activePlayers[otherPlayer] = true
            
            if not isValidTarget(self, otherPlayer) then
                self:ClearTracer(otherPlayer)
                continue
            end
            
            local otherCharacter = otherPlayer.Character
            local tracerTarget = otherCharacter:FindFirstChild("HumanoidRootPart")
            if not tracerTarget then
                self:ClearTracer(otherPlayer)
                continue
            end
            
            if not self.Caches.TracerCache[otherPlayer] then
                self.Caches.TracerCache[otherPlayer] = self:CreateTracer(otherPlayer)
            end
            
            local tracerData = self.Caches.TracerCache[otherPlayer]
            local targetScreenPos, targetOnScreen = currentCamera:WorldToViewportPoint(tracerTarget.Position)
            local targetTo = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
            
            tracerData.TargetFrom = originPos
            tracerData.TargetTo = targetTo
            
            if not tracerData.Initialized then
                tracerData.CurrentFrom = originPos
                tracerData.CurrentTo = targetTo
                tracerData.Initialized = true
            else
                tracerData.CurrentFrom = lerpVector2(tracerData.CurrentFrom, originPos, posLerp)
                tracerData.CurrentTo = lerpVector2(tracerData.CurrentTo, targetTo, posLerp)
            end
            
            tracerData.Line.From = tracerData.CurrentFrom
            tracerData.Line.To = tracerData.CurrentTo
            tracerData.Line.Color = self.Config.TracerColor
            tracerData.Line.Visible = targetOnScreen
        end
    end
    
    for player, _ in pairs(self.Caches.TracerCache) do
        if not activePlayers[player] then
            self:ClearTracer(player)
        end
    end
end

function espModule:UpdateChams()
    if not self.State.ChamsEnabled then
        self:ClearAllChams()
        return
    end
    
    if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        self:ClearAllChams()
        return
    end
    
    local activePlayers = {}
    
    for _, otherPlayer in ipairs(playersService:GetPlayers()) do
        if otherPlayer ~= localPlayer then
            activePlayers[otherPlayer] = true
            
            if not isValidTarget(self, otherPlayer) then
                self:ClearChams(otherPlayer)
                continue
            end
            
            if not self.Caches.ChamsCache[otherPlayer] then
                self.Caches.ChamsCache[otherPlayer] = self:CreateChams(otherPlayer)
            else
                local highlight = self.Caches.ChamsCache[otherPlayer]
                highlight.FillColor = self.Config.ChamsColor
                highlight.OutlineColor = self.Config.ChamsOutlineColor
                highlight.FillTransparency = self.Config.ChamsFillTransparency
            end
        end
    end
    
    for player, _ in pairs(self.Caches.ChamsCache) do
        if not activePlayers[player] then
            self:ClearChams(player)
        end
    end
end

function espModule:UpdateWireframe()
    if not self.State.WireframeEnabled then
        self:ClearAllWireframes()
        return
    end
    
    if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        self:ClearAllWireframes()
        return
    end
    
    local activePlayers = {}
    
    for _, otherPlayer in ipairs(playersService:GetPlayers()) do
        if otherPlayer ~= localPlayer then
            activePlayers[otherPlayer] = true
            
            if not isValidTarget(self, otherPlayer) then
                self:ClearWireframe(otherPlayer)
                continue
            end
            
            local otherCharacter = otherPlayer.Character
            
            if not self.Caches.WireframeCache[otherPlayer] then
                self.Caches.WireframeCache[otherPlayer] = self:CreateWireframe(otherPlayer)
            else
                local wireframeData = self.Caches.WireframeCache[otherPlayer]
                
                if wireframeData.Character ~= otherCharacter then
                    self:ClearWireframe(otherPlayer)
                    self.Caches.WireframeCache[otherPlayer] = self:CreateWireframe(otherPlayer)
                else
                    for partName, box in pairs(wireframeData.Boxes) do
                        if box and box.Parent then
                            box.Color3 = self.Config.WireframeColor
                            box.Transparency = self.Config.WireframeTransparency
                        end
                    end
                    
                    for partName, guiTable in pairs(wireframeData.SurfaceGuis) do
                        for _, gui in ipairs(guiTable) do
                            if gui and gui.Parent then
                                local frame = gui:FindFirstChild("WireframeFrame")
                                if frame then
                                    frame.BackgroundColor3 = self.Config.WireframeSurfaceColor
                                    frame.BackgroundTransparency = self.Config.WireframeSurfaceTransparency
                                    local stroke = frame:FindFirstChildOfClass("UIStroke")
                                    if stroke then
                                        stroke.Color = self.Config.WireframeColor
                                        stroke.Transparency = self.Config.WireframeTransparency
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    for player, _ in pairs(self.Caches.WireframeCache) do
        if not activePlayers[player] then
            self:ClearWireframe(player)
        end
    end
end

function espModule:UpdateRing()
    if not self.State.RingEnabled then
        self:ClearAllRings()
        return
    end
    
    if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        self:ClearAllRings()
        return
    end
    
    local activePlayers = {}
    
    for _, otherPlayer in ipairs(playersService:GetPlayers()) do
        if otherPlayer ~= localPlayer then
            activePlayers[otherPlayer] = true
            
            if not isValidTarget(self, otherPlayer) then
                self:ClearRing(otherPlayer)
                continue
            end
            
            local otherCharacter = otherPlayer.Character
            local otherRoot = otherCharacter.HumanoidRootPart
            
            if not self.Caches.RingCache[otherPlayer] then
                self.Caches.RingCache[otherPlayer] = self:CreateRing(otherPlayer)
            end
            
            local data = self.Caches.RingCache[otherPlayer]
            if data then
                data.Root = otherRoot
                data.Ring.Color3 = self.Config.RingColor
                data.Ring.Visible = true
            end
        end
    end
    
    for player, _ in pairs(self.Caches.RingCache) do
        if not activePlayers[player] then
            self:ClearRing(player)
        end
    end
end

function espModule:UpdateAnimations(dt)
    local t = tick()
    currentRotation = (currentRotation - self.Config.RotateSpeed * dt) % 360
    
    for _, boxDrawings in pairs(self.Caches.BoxCache) do
        if self.Config.BoxGradientEnabled and boxDrawings.Gradient then
            boxDrawings.Gradient.Rotation = currentRotation
        end
    end
    
    for _, data in pairs(self.Caches.RingCache) do
        if data and data.Root and data.Ring and data.Ring.Visible then
            local yOffset = math.sin(t * self.Config.ScanSpeed) * self.Config.ScanHeight
            data.Holder.CFrame = data.Root.CFrame * CFrame.new(0, yOffset, 0)
            data.Ring.Transparency = 0.2 + (math.abs(math.sin(t * self.Config.ScanSpeed)) * 0.4)
        end
    end
end

function espModule:SetBoxEnabled(value)
    self.State.BoxEnabled = value
    if not value and not isAnyBoxFeatureEnabled(self) then
        self:ClearAllBoxes()
    end
end

function espModule:SetNameEnabled(value)
    self.State.NameEnabled = value
    if not value and not isAnyBoxFeatureEnabled(self) then
        self:ClearAllBoxes()
    end
end

function espModule:SetDistanceEnabled(value)
    self.State.DistanceEnabled = value
    if not value and not isAnyBoxFeatureEnabled(self) then
        self:ClearAllBoxes()
    end
end

function espModule:SetHealthTextEnabled(value)
    self.State.HealthTextEnabled = value
    if not value and not isAnyBoxFeatureEnabled(self) then
        self:ClearAllBoxes()
    end
end

function espModule:SetHealthBarEnabled(value)
    self.State.HealthBarEnabled = value
    if not value and not isAnyBoxFeatureEnabled(self) then
        self:ClearAllBoxes()
    end
end

function espModule:SetArmorBarEnabled(value)
    self.State.ArmorBarEnabled = value
    if not value and not isAnyBoxFeatureEnabled(self) then
        self:ClearAllBoxes()
    end
end

function espModule:SetSkeletonEnabled(value)
    self.State.SkeletonEnabled = value
    if not value then
        self:ClearAllSkeletons()
    end
end

function espModule:SetTracerEnabled(value)
    self.State.TracerEnabled = value
    if not value then
        self:ClearAllTracers()
    end
end

function espModule:SetChamsEnabled(value)
    self.State.ChamsEnabled = value
    if not value then
        self:ClearAllChams()
    end
end

function espModule:SetWireframeEnabled(value)
    self.State.WireframeEnabled = value
    if not value then
        self:ClearAllWireframes()
    end
end

function espModule:SetRingEnabled(value)
    self.State.RingEnabled = value
    if not value then
        self:ClearAllRings()
    end
end

function espModule:InitiateBox(color)
    self.Config.BoxColor = color or self.Config.BoxColor
    self.State.BoxEnabled = true
end

function espModule:InitiateName(value)
    self.State.NameEnabled = value
end

function espModule:InitiateDistance(value)
    self.State.DistanceEnabled = value
end

function espModule:InitiateSkeleton(color)
    self.Config.SkeletonColor = color or self.Config.SkeletonColor
    self.State.SkeletonEnabled = true
end

function espModule:InitiateHealthText(value)
    self.State.HealthTextEnabled = value
end

function espModule:InitiateHealthBar(value)
    self.State.HealthBarEnabled = value
end

function espModule:InitiateArmorBar(value)
    self.State.ArmorBarEnabled = value
end

function espModule:InitiateTracer(color, origin)
    self.Config.TracerColor = color or self.Config.TracerColor
    self.Config.TracerOrigin = origin or self.Config.TracerOrigin
    self.State.TracerEnabled = true
end

function espModule:InitiateChams(color)
    self.Config.ChamsColor = color or self.Config.ChamsColor
    self.State.ChamsEnabled = true
end

function espModule:InitiateWireframe(color)
    self.Config.WireframeColor = color or self.Config.WireframeColor
    self.Config.WireframeSurfaceColor = color or self.Config.WireframeSurfaceColor
    self.State.WireframeEnabled = true
end

function espModule:InitiateRing(color)
    self.Config.RingColor = color or self.Config.RingColor
    self.State.RingEnabled = true
end

function espModule:TeamCheck(value)
    self.Config.TeamCheck = value
end

function espModule:SetDistance(value)
    self.Config.ESPDistance = value
end

function espModule:Cleanup()
    self:ClearAllBoxes()
    self:ClearAllSkeletons()
    self:ClearAllTracers()
    self:ClearAllChams()
    self:ClearAllWireframes()
    self:ClearAllRings()
end

function espModule:Destroy()
    self:Cleanup()
    
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    
    if renderConnection then
        renderConnection:Disconnect()
        renderConnection = nil
    end
    
    if self.EspGui then
        self.EspGui:Destroy()
        self.EspGui = nil
    end
    
    self.State.BoxEnabled = false
    self.State.NameEnabled = false
    self.State.DistanceEnabled = false
    self.State.SkeletonEnabled = false
    self.State.HealthTextEnabled = false
    self.State.HealthBarEnabled = false
    self.State.ArmorBarEnabled = false
    self.State.TracerEnabled = false
    self.State.ChamsEnabled = false
    self.State.WireframeEnabled = false
    self.State.RingEnabled = false
end

function espModule:Initialize()
    self.EspGui = Instance.new("ScreenGui")
    self.EspGui.Name = "MatchaEspGui"
    self.EspGui.Parent = localPlayer.PlayerGui
    self.EspGui.IgnoreGuiInset = true
    self.EspGui.ResetOnSpawn = false
    
    playersService.PlayerRemoving:Connect(function(removedPlayer)
        safeCall(function()
            self:ClearBox(removedPlayer)
            self:ClearSkeleton(removedPlayer)
            self:ClearTracer(removedPlayer)
            self:ClearChams(removedPlayer)
            self:ClearWireframe(removedPlayer)
            self:ClearRing(removedPlayer)
        end)
    end)
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            player.CharacterAdded:Connect(function(newCharacter)
                safeCall(function()
                    self:ClearBox(player)
                    self:ClearSkeleton(player)
                    self:ClearTracer(player)
                    self:ClearChams(player)
                    self:ClearWireframe(player)
                    self:ClearRing(player)
                end)
            end)
        end
    end
    
    playersService.PlayerAdded:Connect(function(addedPlayer)
        addedPlayer.CharacterAdded:Connect(function(newCharacter)
            safeCall(function()
                self:ClearBox(addedPlayer)
                self:ClearSkeleton(addedPlayer)
                self:ClearTracer(addedPlayer)
                self:ClearChams(addedPlayer)
                self:ClearWireframe(addedPlayer)
                self:ClearRing(addedPlayer)
            end)
            
            local humanoid = newCharacter:WaitForChild("Humanoid", 5)
            if humanoid then
                humanoid.Died:Connect(function()
                    safeCall(function()
                        self:ClearBox(addedPlayer)
                        self:ClearSkeleton(addedPlayer)
                        self:ClearTracer(addedPlayer)
                        self:ClearChams(addedPlayer)
                        self:ClearWireframe(addedPlayer)
                        self:ClearRing(addedPlayer)
                    end)
                end)
            end
        end)
    end)
    
    renderConnection = runService.RenderStepped:Connect(function(dt)
        safeCall(function()
            self:UpdateBox(dt)
            self:UpdateSkeleton(dt)
            self:UpdateTracer(dt)
            self:UpdateChams()
            self:UpdateWireframe()
            self:UpdateRing()
            self:UpdateAnimations(dt)
        end)
    end)
end

return espModule
