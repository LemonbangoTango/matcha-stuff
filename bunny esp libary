local playersService = game:GetService("Players")
local workspaceService = game:GetService("Workspace")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")

local espModule = {}
espModule.__index = espModule

espModule.Config = {
    TeamCheck = true,
    ESPDistance = 1000,
    BoxColor = Color3.new(0.403922, 0.34902, 0.701961),
    BoxGradientEnabled = false,
    BoxGradientColor1 = Color3.new(0.403922, 0.34902, 0.701961),
    BoxGradientColor2 = Color3.new(0.8, 0.4, 1),
    BoxFillTransparency = 0.5,
    RotateSpeed = 120,
    BoxOutlineEnabled = true,
    BoxOutlineColor = Color3.new(0, 0, 0),
    SkeletonColor = Color3.new(0.403922, 0.34902, 0.701961),
    ChamsColor = Color3.new(0.403922, 0.34902, 0.701961),
    ChamsFillTransparency = 0.5,
    ChamsOutlineColor = Color3.new(1, 1, 1),
    WireframeColor = Color3.new(0.403922, 0.34902, 0.701961),
    WireframeThickness = 1,
    TracerOrigin = "Bottom Screen",
    TracerColor = Color3.new(0.403922, 0.34902, 0.701961),
    HealthBarLerpSpeed = 0.15,
    PositionLerpSpeed = 0.3,
    ColorLerpSpeed = 0.1,
    HealthColorFull = Color3.fromRGB(0, 255, 0),
    HealthColorMid = Color3.fromRGB(255, 255, 0),
    HealthColorLow = Color3.fromRGB(255, 0, 0),
    ArmorBarColor = Color3.fromRGB(0, 150, 255),
    RingColor = Color3.fromRGB(255, 255, 255),
    ScanSpeed = 2.5,
    ScanHeight = 3.5,
    RingRadius = 2.5
}

espModule.State = {
    BoxEnabled = false,
    NameEnabled = false,
    DistanceEnabled = false,
    SkeletonEnabled = false,
    HealthTextEnabled = false,
    HealthBarEnabled = false,
    ArmorBarEnabled = false,
    TracerEnabled = false,
    ChamsEnabled = false,
    WireframeEnabled = false,
    RingEnabled = false
}

espModule.Caches = {
    BoxCache = {},
    SkeletonCache = {},
    TracerCache = {},
    ChamsCache = {},
    WireframeCache = {},
    RingCache = {}
}

local localPlayer = playersService.LocalPlayer
local currentCamera = workspaceService.CurrentCamera
local heartbeatConnection = nil
local renderConnection = nil
local currentRotation = 0

local BODY_PARTS = {
    "Head", "Torso", "UpperTorso", "LowerTorso",
    "Left Arm", "Right Arm", "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand",
    "Left Leg", "Right Leg", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot"
}

local CUBE_EDGES = {
    {1, 2}, {2, 3}, {3, 4}, {4, 1},
    {5, 6}, {6, 7}, {7, 8}, {8, 5},
    {1, 5}, {2, 6}, {3, 7}, {4, 8},
    {1, 3}, {2, 4},
    {5, 7}, {6, 8},
    {1, 6}, {2, 5},
    {4, 7}, {3, 8},
    {1, 8}, {4, 5},
    {2, 7}, {3, 6}
}

local TOTAL_LINES = #CUBE_EDGES

local function safeCall(callback)
    local success, errorMessage = pcall(callback)
    if not success then
        warn("MatchaEsp Error: " .. tostring(errorMessage))
    end
end

local function lerpNumber(a, b, t)
    return a + (b - a) * math.clamp(t, 0, 1)
end

local function lerpVector2(a, b, t)
    return Vector2.new(
        lerpNumber(a.X, b.X, t),
        lerpNumber(a.Y, b.Y, t)
    )
end

local function lerpColor3(a, b, t)
    return Color3.new(
        lerpNumber(a.R, b.R, t),
        lerpNumber(a.G, b.G, t),
        lerpNumber(a.B, b.B, t)
    )
end

local function getHealthColor(healthPercent, config)
    if healthPercent > 50 then
        return config.HealthColorFull
    elseif healthPercent > 25 then
        local t = (healthPercent - 25) / 25
        return lerpColor3(config.HealthColorMid, config.HealthColorFull, t)
    else
        local t = healthPercent / 25
        return lerpColor3(config.HealthColorLow, config.HealthColorMid, t)
    end
end

local function getCameraDistance(worldPosition)
    return (currentCamera.CFrame.Position - worldPosition).Magnitude
end

local function isAnyBoxFeatureEnabled(self)
    return self.State.BoxEnabled or 
           self.State.NameEnabled or 
           self.State.DistanceEnabled or 
           self.State.HealthTextEnabled or 
           self.State.HealthBarEnabled or 
           self.State.ArmorBarEnabled
end

local function isAnyESPEnabled(self)
    return isAnyBoxFeatureEnabled(self) or
           self.State.SkeletonEnabled or
           self.State.TracerEnabled or
           self.State.ChamsEnabled or
           self.State.WireframeEnabled or
           self.State.RingEnabled
end

local function isTeammate(self, otherPlayer)
    if not self.Config.TeamCheck then return false end
    if not localPlayer.Team then return false end
    if not otherPlayer.Team then return false end
    return otherPlayer.Team == localPlayer.Team
end

local function isValidTarget(self, otherPlayer)
    if otherPlayer == localPlayer then return false end
    
    local otherCharacter = otherPlayer.Character
    if not otherCharacter then return false end
    
    local otherRoot = otherCharacter:FindFirstChild("HumanoidRootPart")
    if not otherRoot then return false end
    
    local otherHumanoid = otherCharacter:FindFirstChild("Humanoid")
    if not otherHumanoid then return false end
    if otherHumanoid.Health <= 0 then return false end
    
    local distance = getCameraDistance(otherRoot.Position)
    if distance > self.Config.ESPDistance then return false end
    
    if isTeammate(self, otherPlayer) then return false end
    
    return true
end

local function getBoxCorners(part)
    local cf = part.CFrame
    local size = part.Size
    local sx, sy, sz = size.X / 2, size.Y / 2, size.Z / 2
    
    local corners = {
        cf * CFrame.new(-sx, -sy, -sz),
        cf * CFrame.new(sx, -sy, -sz),
        cf * CFrame.new(sx, -sy, sz),
        cf * CFrame.new(-sx, -sy, sz),
        cf * CFrame.new(-sx, sy, -sz),
        cf * CFrame.new(sx, sy, -sz),
        cf * CFrame.new(sx, sy, sz),
        cf * CFrame.new(-sx, sy, sz)
    }
    
    return corners
end

local function worldToScreen(position)
    local screenPos, onScreen = currentCamera:WorldToViewportPoint(position)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen, screenPos.Z
end

function espModule:CreateBox(_)
    local boxDrawings = {
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthText = Drawing.new("Text"),
        HealthBarBackground = Drawing.new("Square"),
        HealthBar = Drawing.new("Square"),
        HealthBarOutline = Drawing.new("Square"),
        ArmorText = Drawing.new("Text"),
        ArmorBarBackground = Drawing.new("Square"),
        ArmorBar = Drawing.new("Square"),
        ArmorBarOutline = Drawing.new("Square"),
        FillFrame = Instance.new("Frame"),
        Gradient = Instance.new("UIGradient"),
        Stroke = Instance.new("UIStroke"),
        CurrentHealth = 100,
        TargetHealth = 100,
        CurrentArmor = 0,
        TargetArmor = 0,
        CurrentHealthColor = self.Config.HealthColorFull,
        TargetHealthColor = self.Config.HealthColorFull,
        CurrentPosition = Vector2.new(0, 0),
        TargetPosition = Vector2.new(0, 0),
        CurrentSize = Vector2.new(0, 0),
        TargetSize = Vector2.new(0, 0),
        Initialized = false
    }
    
    boxDrawings.FillFrame.Parent = self.EspGui
    boxDrawings.FillFrame.BorderSizePixel = 0
    boxDrawings.FillFrame.BackgroundTransparency = 1
    boxDrawings.FillFrame.Visible = false
    boxDrawings.Gradient.Parent = boxDrawings.FillFrame
    boxDrawings.Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, self.Config.BoxGradientColor1),
        ColorSequenceKeypoint.new(0.5, self.Config.BoxGradientColor2),
        ColorSequenceKeypoint.new(1, self.Config.BoxGradientColor1)
    })
    boxDrawings.Stroke.Parent = boxDrawings.FillFrame
    boxDrawings.Stroke.Thickness = 1.2
    boxDrawings.Stroke.Color = self.Config.BoxOutlineColor
    boxDrawings.Stroke.Transparency = 0
    boxDrawings.Stroke.Enabled = self.Config.BoxOutlineEnabled
    
    boxDrawings.Box.Thickness = 1
    boxDrawings.Box.Color = self.Config.BoxColor
    boxDrawings.Box.Filled = false
    boxDrawings.Box.Visible = false
    boxDrawings.Box.Transparency = 1
    
    boxDrawings.BoxOutline.Thickness = 3
    boxDrawings.BoxOutline.Color = self.Config.BoxOutlineColor
    boxDrawings.BoxOutline.Filled = false
    boxDrawings.BoxOutline.Visible = false
    boxDrawings.BoxOutline.Transparency = 1
    
    boxDrawings.Name.Size = 14
    boxDrawings.Name.Color = Color3.new(1, 1, 1)
    boxDrawings.Name.Outline = true
    boxDrawings.Name.OutlineColor = Color3.new(0, 0, 0)
    boxDrawings.Name.Center = true
    boxDrawings.Name.Visible = false
    boxDrawings.Name.Font = 2
    boxDrawings.Name.Transparency = 1
    
    boxDrawings.Distance.Size = 13
    boxDrawings.Distance.Color = Color3.fromRGB(200, 200, 200)
    boxDrawings.Distance.Outline = true
    boxDrawings.Distance.OutlineColor = Color3.new(0, 0, 0)
    boxDrawings.Distance.Center = true
    boxDrawings.Distance.Visible = false
    boxDrawings.Distance.Font = 2
    boxDrawings.Distance.Transparency = 1
    
    boxDrawings.HealthText.Size = 12
    boxDrawings.HealthText.Color = Color3.new(1, 1, 1)
    boxDrawings.HealthText.Outline = true
    boxDrawings.HealthText.OutlineColor = Color3.new(0, 0, 0)
    boxDrawings.HealthText.Center = false
    boxDrawings.HealthText.Visible = false
    boxDrawings.HealthText.Font = 2
    boxDrawings.HealthText.Transparency = 1
    
    boxDrawings.HealthBarBackground.Thickness = 1
    boxDrawings.HealthBarBackground.Color = Color3.fromRGB(30, 30, 30)
    boxDrawings.HealthBarBackground.Filled = true
    boxDrawings.HealthBarBackground.Visible = false
    boxDrawings.HealthBarBackground.Transparency = 0.3
    
    boxDrawings.HealthBarOutline.Thickness = 1
    boxDrawings.HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
    boxDrawings.HealthBarOutline.Filled = false
    boxDrawings.HealthBarOutline.Visible = false
    boxDrawings.HealthBarOutline.Transparency = 1
    
    boxDrawings.HealthBar.Thickness = 1
    boxDrawings.HealthBar.Color = self.Config.HealthColorFull
    boxDrawings.HealthBar.Filled = true
    boxDrawings.HealthBar.Visible = false
    boxDrawings.HealthBar.Transparency = 1
    
    boxDrawings.ArmorText.Size = 12
    boxDrawings.ArmorText.Color = self.Config.ArmorBarColor
    boxDrawings.ArmorText.Outline = true
    boxDrawings.ArmorText.OutlineColor = Color3.new(0, 0, 0)
    boxDrawings.ArmorText.Center = false
    boxDrawings.ArmorText.Visible = false
    boxDrawings.ArmorText.Font = 2
    boxDrawings.ArmorText.Transparency = 1
    
    boxDrawings.ArmorBarBackground.Thickness = 1
    boxDrawings.ArmorBarBackground.Color = Color3.fromRGB(30, 30, 30)
    boxDrawings.ArmorBarBackground.Filled = true
    boxDrawings.ArmorBarBackground.Visible = false
    boxDrawings.ArmorBarBackground.Transparency = 0.3
    
    boxDrawings.ArmorBarOutline.Thickness = 1
    boxDrawings.ArmorBarOutline.Color = Color3.fromRGB(0, 0, 0)
    boxDrawings.ArmorBarOutline.Filled = false
    boxDrawings.ArmorBarOutline.Visible = false
    boxDrawings.ArmorBarOutline.Transparency = 1
    
    boxDrawings.ArmorBar.Thickness = 1
    boxDrawings.ArmorBar.Color = self.Config.ArmorBarColor
    boxDrawings.ArmorBar.Filled = true
    boxDrawings.ArmorBar.Visible = false
    boxDrawings.ArmorBar.Transparency = 1
    
    return boxDrawings
end

function espModule:CreateSkeleton(targetPlayer)
    local targetCharacter = targetPlayer.Character
    local isR6 = targetCharacter and targetCharacter:FindFirstChild("Torso") and not targetCharacter:FindFirstChild("UpperTorso")
    
    local skeletonData = {
        IsR6 = isR6,
        Lines = {},
        CurrentPositions = {},
        TargetPositions = {}
    }
    
    if isR6 then
        local lineNames = {"HeadToTorso", "TorsoToLeftArm", "TorsoToRightArm", "TorsoToLeftLeg", "TorsoToRightLeg"}
        for _, name in ipairs(lineNames) do
            local line = Drawing.new("Line")
            line.Thickness = 2
            line.Color = self.Config.SkeletonColor
            line.Visible = false
            line.Transparency = 1
            skeletonData.Lines[name] = line
            skeletonData.CurrentPositions[name .. "From"] = Vector2.new(0, 0)
            skeletonData.CurrentPositions[name .. "To"] = Vector2.new(0, 0)
            skeletonData.TargetPositions[name .. "From"] = Vector2.new(0, 0)
            skeletonData.TargetPositions[name .. "To"] = Vector2.new(0, 0)
        end
    else
        local lineNames = {
            "HeadToUpperTorso", "UpperTorsoToLowerTorso",
            "UpperTorsoToLeftUpperArm", "LeftUpperArmToLeftLowerArm", "LeftLowerArmToLeftHand",
            "UpperTorsoToRightUpperArm", "RightUpperArmToRightLowerArm", "RightLowerArmToRightHand",
            "LowerTorsoToLeftUpperLeg", "LeftUpperLegToLeftLowerLeg", "LeftLowerLegToLeftFoot",
            "LowerTorsoToRightUpperLeg", "RightUpperLegToRightLowerLeg", "RightLowerLegToRightFoot"
        }
        for _, name in ipairs(lineNames) do
            local line = Drawing.new("Line")
            line.Thickness = 2
            line.Color = self.Config.SkeletonColor
            line.Visible = false
            line.Transparency = 1
            skeletonData.Lines[name] = line
            skeletonData.CurrentPositions[name .. "From"] = Vector2.new(0, 0)
            skeletonData.CurrentPositions[name .. "To"] = Vector2.new(0, 0)
            skeletonData.TargetPositions[name .. "From"] = Vector2.new(0, 0)
            skeletonData.TargetPositions[name .. "To"] = Vector2.new(0, 0)
        end
    end
    
    skeletonData.Initialized = false
    return skeletonData
end

function espModule:CreateTracer(_)
    local tracerData = {
        Line = Drawing.new("Line"),
        CurrentFrom = Vector2.new(0, 0),
        CurrentTo = Vector2.new(0, 0),
        TargetFrom = Vector2.new(0, 0),
        TargetTo = Vector2.new(0, 0),
        Initialized = false
    }
    
    tracerData.Line.Thickness = 1.5
    tracerData.Line.Color = self.Config.TracerColor
    tracerData.Line.Visible = false
    tracerData.Line.Transparency = 1
    
    return tracerData
end

function espModule:CreateChams(targetPlayer)
    local highlight = Instance.new("Highlight")
    highlight.FillColor = self.Config.ChamsColor
    highlight.OutlineColor = self.Config.ChamsOutlineColor
    highlight.FillTransparency = self.Config.ChamsFillTransparency
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = targetPlayer.Character
    highlight.Adornee = targetPlayer.Character
    return highlight
end

function espModule:CreateWireframe(targetPlayer)
    local wireframeData = {
        Parts = {},
        Lines = {}
    }
    
    for _, partName in ipairs(BODY_PARTS) do
        wireframeData.Lines[partName] = {}
        for i = 1, TOTAL_LINES do
            local line = Drawing.new("Line")
            line.Thickness = self.Config.WireframeThickness
            line.Color = self.Config.WireframeColor
            line.Visible = false
            line.Transparency = 1
            wireframeData.Lines[partName][i] = line
        end
    end
    
    return wireframeData
end

function espModule:CreateRing(player)
    if player == localPlayer then return nil end
    local holder = Instance.new("Part")
    holder.Name = "ESP_Holder_" .. player.Name
    holder.Transparency = 1
    holder.CanCollide = false
    holder.Anchored = true
    holder.Parent = workspace
    local ring = Instance.new("CylinderHandleAdornment")
    ring.Adornee = holder
    ring.AlwaysOnTop = true
    ring.ZIndex = 10
    ring.Color3 = self.Config.RingColor
    ring.InnerRadius = self.Config.RingRadius - 0.1
    ring.Radius = self.Config.RingRadius
    ring.Height = 0.08
    ring.CFrame = CFrame.Angles(math.rad(90), 0, 0)
    ring.Parent = holder
    ring.Visible = false
    return {Holder = holder, Ring = ring, Root = nil}
end

function espModule:ClearBox(targetPlayer)
    local cache = self.Caches.BoxCache[targetPlayer]
    if cache then
        pcall(function() cache.Box:Remove() end)
        pcall(function() cache.BoxOutline:Remove() end)
        pcall(function() cache.Name:Remove() end)
        pcall(function() cache.Distance:Remove() end)
        pcall(function() cache.HealthText:Remove() end)
        pcall(function() cache.HealthBarBackground:Remove() end)
        pcall(function() cache.HealthBar:Remove() end)
        pcall(function() cache.HealthBarOutline:Remove() end)
        pcall(function() cache.ArmorText:Remove() end)
        pcall(function() cache.ArmorBarBackground:Remove() end)
        pcall(function() cache.ArmorBar:Remove() end)
        pcall(function() cache.ArmorBarOutline:Remove() end)
        pcall(function() cache.FillFrame:Destroy() end)
        self.Caches.BoxCache[targetPlayer] = nil
    end
end

function espModule:ClearSkeleton(targetPlayer)
    local cache = self.Caches.SkeletonCache[targetPlayer]
    if cache then
        for _, line in pairs(cache.Lines) do
            pcall(function() line:Remove() end)
        end
        self.Caches.SkeletonCache[targetPlayer] = nil
    end
end

function espModule:ClearTracer(targetPlayer)
    local cache = self.Caches.TracerCache[targetPlayer]
    if cache then
        pcall(function() cache.Line:Remove() end)
        self.Caches.TracerCache[targetPlayer] = nil
    end
end

function espModule:ClearChams(targetPlayer)
    local cache = self.Caches.ChamsCache[targetPlayer]
    if cache then
        pcall(function() cache:Destroy() end)
        self.Caches.ChamsCache[targetPlayer] = nil
    end
end

function espModule:ClearWireframe(targetPlayer)
    local cache = self.Caches.WireframeCache[targetPlayer]
    if cache then
        for partName, lines in pairs(cache.Lines) do
            for _, line in ipairs(lines) do
                pcall(function() line:Remove() end)
            end
        end
        self.Caches.WireframeCache[targetPlayer] = nil
    end
end

function espModule:ClearRing(targetPlayer)
    local cache = self.Caches.RingCache[targetPlayer]
    if cache then
        pcall(function() cache.Holder:Destroy() end)
        self.Caches.RingCache[targetPlayer] = nil
    end
end

function espModule:ClearAllBoxes()
    for player, _ in pairs(self.Caches.BoxCache) do
        self:ClearBox(player)
    end
end

function espModule:ClearAllSkeletons()
    for player, _ in pairs(self.Caches.SkeletonCache) do
        self:ClearSkeleton(player)
    end
end

function espModule:ClearAllTracers()
    for player, _ in pairs(self.Caches.TracerCache) do
        self:ClearTracer(player)
    end
end

function espModule:ClearAllChams()
    for player, _ in pairs(self.Caches.ChamsCache) do
        self:ClearChams(player)
    end
end

function espModule:ClearAllWireframes()
    for player, _ in pairs(self.Caches.WireframeCache) do
        self:ClearWireframe(player)
    end
end

function espModule:ClearAllRings()
    for player, _ in pairs(self.Caches.RingCache) do
        self:ClearRing(player)
    end
end

function espModule:HideBox(targetPlayer)
    local boxDrawings = self.Caches.BoxCache[targetPlayer]
    if boxDrawings then
        boxDrawings.Box.Visible = false
        boxDrawings.BoxOutline.Visible = false
        boxDrawings.FillFrame.Visible = false
        boxDrawings.Name.Visible = false
        boxDrawings.Distance.Visible = false
        boxDrawings.HealthText.Visible = false
        boxDrawings.HealthBar.Visible = false
        boxDrawings.HealthBarBackground.Visible = false
        boxDrawings.HealthBarOutline.Visible = false
        boxDrawings.ArmorText.Visible = false
        boxDrawings.ArmorBar.Visible = false
        boxDrawings.ArmorBarBackground.Visible = false
        boxDrawings.ArmorBarOutline.Visible = false
        if boxDrawings.Stroke then boxDrawings.Stroke.Enabled = false end
    end
end

function espModule:HideSkeleton(targetPlayer)
    local cache = self.Caches.SkeletonCache[targetPlayer]
    if cache then
        for _, line in pairs(cache.Lines) do
            line.Visible = false
        end
    end
end

function espModule:HideTracer(targetPlayer)
    local cache = self.Caches.TracerCache[targetPlayer]
    if cache then
        cache.Line.Visible = false
    end
end

function espModule:HideWireframe(targetPlayer)
    local cache = self.Caches.WireframeCache[targetPlayer]
    if cache then
        for partName, lines in pairs(cache.Lines) do
            for _, line in ipairs(lines) do
                line.Visible = false
            end
        end
    end
end

function espModule:HideRing(targetPlayer)
    local cache = self.Caches.RingCache[targetPlayer]
    if cache and cache.Ring then
        cache.Ring.Visible = false
    end
end

function espModule:UpdateBox(dt)
    if not self or not self.State or not self.Config or not self.Caches then return end
    
    local shouldDraw = isAnyBoxFeatureEnabled(self)
    
    if not shouldDraw then
        self:ClearAllBoxes()
        return
    end
    
    if not localPlayer.Character then
        self:ClearAllBoxes()
        return
    end
    
    local localRoot = localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not localRoot then
        self:ClearAllBoxes()
        return
    end

    local cameraPos = currentCamera.CFrame.Position
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    local colorLerp = math.clamp(self.Config.ColorLerpSpeed * dt * 60, 0, 1)
    local healthLerp = math.clamp(self.Config.HealthBarLerpSpeed * dt * 60, 0, 1)

    for _, otherPlayer in ipairs(playersService:GetPlayers()) do
        if otherPlayer ~= localPlayer then
            activePlayers[otherPlayer] = true
            
            local success, err = pcall(function()
                if not isValidTarget(self, otherPlayer) then
                    self:ClearBox(otherPlayer)
                    return
                end
                
                local otherCharacter = otherPlayer.Character
                local otherRoot = otherCharacter:FindFirstChild("HumanoidRootPart")
                local otherHumanoid = otherCharacter:FindFirstChild("Humanoid")
                local distance = getCameraDistance(otherRoot.Position)
                
                if not self.Caches.BoxCache[otherPlayer] then
                    self.Caches.BoxCache[otherPlayer] = self:CreateBox(otherPlayer)
                end

                local boxDrawings = self.Caches.BoxCache[otherPlayer]
                local rootScreenPos, rootOnScreen = currentCamera:WorldToViewportPoint(otherRoot.Position)

                if not rootOnScreen then
                    self:HideBox(otherPlayer)
                    return
                end
                
                local headPart = otherCharacter:FindFirstChild("Head")
                local headTopPos = (headPart and headPart.Position + Vector3.new(0, 0.8, 0)) or (otherRoot.Position + Vector3.new(0, 2.5, 0))
                local feetPos = otherRoot.Position - Vector3.new(0, 3, 0)

                local headTopScreenPos = currentCamera:WorldToViewportPoint(headTopPos)
                local feetScreenPos = currentCamera:WorldToViewportPoint(feetPos)

                local height = math.abs(headTopScreenPos.Y - feetScreenPos.Y)
                local width = height * 0.55
                
                local centerPos = Vector2.new(rootScreenPos.X, (headTopScreenPos.Y + feetScreenPos.Y) / 2)
                local targetTopLeft = centerPos - Vector2.new(width / 2, height / 2)
                local targetSize = Vector2.new(width, height)
                
                if not boxDrawings.Initialized then
                    boxDrawings.CurrentPosition = targetTopLeft
                    boxDrawings.CurrentSize = targetSize
                    boxDrawings.Initialized = true
                else
                    boxDrawings.CurrentPosition = lerpVector2(boxDrawings.CurrentPosition, targetTopLeft, posLerp)
                    boxDrawings.CurrentSize = lerpVector2(boxDrawings.CurrentSize, targetSize, posLerp)
                end
                
                local smoothTopLeft = boxDrawings.CurrentPosition
                local smoothSize = boxDrawings.CurrentSize
                local smoothWidth = smoothSize.X
                local smoothHeight = smoothSize.Y
                local smoothCenterX = smoothTopLeft.X + smoothWidth / 2
                
                local currentHealthVal = otherHumanoid.Health
                local maxHealthVal = otherHumanoid.MaxHealth
                local healthPercent = (currentHealthVal / maxHealthVal) * 100
                
                boxDrawings.TargetHealth = healthPercent
                boxDrawings.CurrentHealth = lerpNumber(boxDrawings.CurrentHealth, boxDrawings.TargetHealth, healthLerp)
                
                local targetHealthColor = getHealthColor(boxDrawings.CurrentHealth, self.Config)
                boxDrawings.CurrentHealthColor = lerpColor3(boxDrawings.CurrentHealthColor, targetHealthColor, colorLerp)
                
                if self.State.BoxEnabled then
                    boxDrawings.Box.Visible = false
                    boxDrawings.BoxOutline.Visible = false
                    boxDrawings.FillFrame.Visible = false

                    if self.Config.BoxGradientEnabled then
                        boxDrawings.FillFrame.Position = UDim2.fromOffset(smoothTopLeft.X, smoothTopLeft.Y)
                        boxDrawings.FillFrame.Size = UDim2.fromOffset(smoothWidth, smoothHeight)
                        boxDrawings.FillFrame.BackgroundTransparency = self.Config.BoxFillTransparency
                        boxDrawings.FillFrame.Visible = true
                        boxDrawings.Stroke.Enabled = self.Config.BoxOutlineEnabled
                        boxDrawings.Stroke.Color = self.Config.BoxOutlineColor
                    else
                        if self.Config.BoxOutlineEnabled then
                            boxDrawings.BoxOutline.Size = Vector2.new(smoothWidth, smoothHeight)
                            boxDrawings.BoxOutline.Position = smoothTopLeft
                            boxDrawings.BoxOutline.Color = self.Config.BoxOutlineColor
                            boxDrawings.BoxOutline.Visible = true
                        end
                        
                        boxDrawings.Box.Size = Vector2.new(smoothWidth, smoothHeight)
                        boxDrawings.Box.Position = smoothTopLeft
                        boxDrawings.Box.Color = self.Config.BoxColor
                        boxDrawings.Box.Visible = true
                    end
                else
                    boxDrawings.Box.Visible = false
                    boxDrawings.BoxOutline.Visible = false
                    boxDrawings.FillFrame.Visible = false
                    if boxDrawings.Stroke then boxDrawings.Stroke.Enabled = false end
                end

                if self.State.NameEnabled then
                    boxDrawings.Name.Position = Vector2.new(smoothCenterX, smoothTopLeft.Y - 18)
                    boxDrawings.Name.Text = otherPlayer.Name
                    boxDrawings.Name.Visible = true
                else
                    boxDrawings.Name.Visible = false
                end

                if self.State.DistanceEnabled then
                    boxDrawings.Distance.Position = Vector2.new(smoothCenterX, smoothTopLeft.Y + smoothHeight + 3)
                    boxDrawings.Distance.Text = math.floor(distance) .. "m"
                    boxDrawings.Distance.Visible = true
                else
                    boxDrawings.Distance.Visible = false
                end

                local barX = smoothTopLeft.X - 6
                local barY = smoothTopLeft.Y

                if self.State.HealthBarEnabled or self.State.HealthTextEnabled then
                    local displayHealth = math.floor(boxDrawings.CurrentHealth)
                    
                    if self.State.HealthTextEnabled then
                        local textY = barY + smoothHeight * (1 - boxDrawings.CurrentHealth / 100)
                        textY = math.clamp(textY, barY, barY + smoothHeight - 10)
                        
                        boxDrawings.HealthText.Position = Vector2.new(barX - 18, textY - 6)
                        boxDrawings.HealthText.Text = tostring(displayHealth)
                        boxDrawings.HealthText.Color = boxDrawings.CurrentHealthColor
                        boxDrawings.HealthText.Visible = true
                    else
                        boxDrawings.HealthText.Visible = false
                    end

                    if self.State.HealthBarEnabled then
                        local barHeight = smoothHeight * (boxDrawings.CurrentHealth / 100)
                        
                        boxDrawings.HealthBarOutline.Size = Vector2.new(4, smoothHeight + 2)
                        boxDrawings.HealthBarOutline.Position = Vector2.new(barX - 1, barY - 1)
                        boxDrawings.HealthBarOutline.Visible = true
                        
                        boxDrawings.HealthBarBackground.Size = Vector2.new(2, smoothHeight)
                        boxDrawings.HealthBarBackground.Position = Vector2.new(barX, barY)
                        boxDrawings.HealthBarBackground.Visible = true
                        
                        boxDrawings.HealthBar.Size = Vector2.new(2, barHeight)
                        boxDrawings.HealthBar.Position = Vector2.new(barX, barY + smoothHeight - barHeight)
                        boxDrawings.HealthBar.Color = boxDrawings.CurrentHealthColor
                        boxDrawings.HealthBar.Visible = true
                    else
                        boxDrawings.HealthBar.Visible = false
                        boxDrawings.HealthBarBackground.Visible = false
                        boxDrawings.HealthBarOutline.Visible = false
                    end
                else
                    boxDrawings.HealthText.Visible = false
                    boxDrawings.HealthBar.Visible = false
                    boxDrawings.HealthBarBackground.Visible = false
                    boxDrawings.HealthBarOutline.Visible = false
                end

                if self.State.ArmorBarEnabled then
                    local bodyEffects = otherCharacter:FindFirstChild("BodyEffects")
                    local armorVal = (bodyEffects and bodyEffects:FindFirstChild("Armor")) and bodyEffects.Armor.Value or 0
                    local armorPercent = math.clamp((armorVal / 200) * 100, 0, 100)
                    
                    boxDrawings.TargetArmor = armorPercent
                    boxDrawings.CurrentArmor = lerpNumber(boxDrawings.CurrentArmor, boxDrawings.TargetArmor, healthLerp)

                    local armorBarX = smoothTopLeft.X + smoothWidth + 2
                    local armorBarHeight = smoothHeight * (boxDrawings.CurrentArmor / 100)
                    
                    boxDrawings.ArmorBarOutline.Size = Vector2.new(4, smoothHeight + 2)
                    boxDrawings.ArmorBarOutline.Position = Vector2.new(armorBarX - 1, barY - 1)
                    boxDrawings.ArmorBarOutline.Visible = true
                    
                    boxDrawings.ArmorBarBackground.Size = Vector2.new(2, smoothHeight)
                    boxDrawings.ArmorBarBackground.Position = Vector2.new(armorBarX, barY)
                    boxDrawings.ArmorBarBackground.Visible = true
                    
                    boxDrawings.ArmorBar.Size = Vector2.new(2, armorBarHeight)
                    boxDrawings.ArmorBar.Position = Vector2.new(armorBarX, barY + smoothHeight - armorBarHeight)
                    boxDrawings.ArmorBar.Color = self.Config.ArmorBarColor
                    boxDrawings.ArmorBar.Visible = boxDrawings.CurrentArmor > 0
                    
                    if self.State.HealthTextEnabled and boxDrawings.CurrentArmor > 0 then
                        local armorTextY = barY + smoothHeight * (1 - boxDrawings.CurrentArmor / 100)
                        armorTextY = math.clamp(armorTextY, barY, barY + smoothHeight - 10)
                        
                        boxDrawings.ArmorText.Position = Vector2.new(armorBarX + 6, armorTextY - 6)
                        boxDrawings.ArmorText.Text = tostring(math.floor(boxDrawings.CurrentArmor))
                        boxDrawings.ArmorText.Color = self.Config.ArmorBarColor
                        boxDrawings.ArmorText.Visible = true
                    else
                        boxDrawings.ArmorText.Visible = false
                    end
                else
                    boxDrawings.ArmorBar.Visible = false
                    boxDrawings.ArmorBarBackground.Visible = false
                    boxDrawings.ArmorBarOutline.Visible = false
                    boxDrawings.ArmorText.Visible = false
                end
            end)
            
            if not success then
                self:ClearBox(otherPlayer)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.BoxCache) do
        if not activePlayers[player] then
            self:ClearBox(player)
        end
    end
end

function espModule:UpdateSkeleton(dt)
    if not self.State.SkeletonEnabled then
        self:ClearAllSkeletons()
        return
    end
    
    if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        self:ClearAllSkeletons()
        return
    end
    
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    
    for _, otherPlayer in ipairs(playersService:GetPlayers()) do
        if otherPlayer ~= localPlayer then
            activePlayers[otherPlayer] = true
            
            if not isValidTarget(self, otherPlayer) then
                self:ClearSkeleton(otherPlayer)
                continue
            end
            
            local otherCharacter = otherPlayer.Character
            
            if not self.Caches.SkeletonCache[otherPlayer] then
                self.Caches.SkeletonCache[otherPlayer] = self:CreateSkeleton(otherPlayer)
            end
            
            local skeletonData = self.Caches.SkeletonCache[otherPlayer]
            local isR6 = skeletonData.IsR6
            
            local function getScreenPos(partName)
                local part = otherCharacter:FindFirstChild(partName)
                if part then
                    local screenPos, onScreen = currentCamera:WorldToViewportPoint(part.Position)
                    return Vector2.new(screenPos.X, screenPos.Y), onScreen
                end
                return Vector2.new(0, 0), false
            end
            
            local function updateLine(lineName, fromPos, toPos, fromOn, toOn)
                local line = skeletonData.Lines[lineName]
                if not line then return end
                
                local fromKey = lineName .. "From"
                local toKey = lineName 
