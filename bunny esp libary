local playersService = game:GetService("Players")
local workspaceService = game:GetService("Workspace")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")

local espModule = {}
espModule.__index = espModule

espModule.Config = {
    TeamCheck = true,
    ESPDistance = 1000,
    VisibilityCheck = false,
    
    BoxEnabled = false,
    BoxColor = Color3.new(0.403922, 0.34902, 0.701961),
    BoxStyle = "Full",
    BoxThickness = 1,
    BoxOutlineEnabled = true,
    BoxOutlineColor = Color3.new(0, 0, 0),
    BoxFilled = false,
    BoxFillTransparency = 0.8,
    BoxRainbow = false,
    
    CornerLength = 0.25,
    
    Box3DEnabled = false,
    Box3DColor = Color3.new(0.403922, 0.34902, 0.701961),
    Box3DThickness = 1,
    
    NameEnabled = false,
    NameColor = Color3.new(1, 1, 1),
    NameSize = 14,
    NameFont = 2,
    ShowDisplayName = false,
    
    DistanceEnabled = false,
    DistanceColor = Color3.fromRGB(200, 200, 200),
    DistanceSize = 13,
    
    HealthBarEnabled = false,
    HealthBarPosition = "Left",
    HealthBarWidth = 2,
    HealthBarOutline = true,
    HealthColorFull = Color3.fromRGB(0, 255, 0),
    HealthColorMid = Color3.fromRGB(255, 255, 0),
    HealthColorLow = Color3.fromRGB(255, 0, 0),
    
    HealthTextEnabled = false,
    HealthTextColor = Color3.new(1, 1, 1),
    HealthTextSize = 12,
    
    ArmorBarEnabled = false,
    ArmorBarPosition = "Right",
    ArmorBarColor = Color3.fromRGB(0, 150, 255),
    ArmorBarWidth = 2,
    
    SkeletonEnabled = false,
    SkeletonColor = Color3.new(0.403922, 0.34902, 0.701961),
    SkeletonThickness = 2,
    
    TracerEnabled = false,
    TracerColor = Color3.new(0.403922, 0.34902, 0.701961),
    TracerOrigin = "Bottom",
    TracerThickness = 1.5,
    TracerOutline = false,
    TracerOutlineColor = Color3.new(0, 0, 0),
    
    HeadDotEnabled = false,
    HeadDotColor = Color3.new(1, 0, 0),
    HeadDotSize = 4,
    HeadDotFilled = true,
    HeadDotOutline = true,
    HeadDotOutlineColor = Color3.new(0, 0, 0),
    
    ChamsEnabled = false,
    ChamsColor = Color3.new(0.403922, 0.34902, 0.701961),
    ChamsFillTransparency = 0.5,
    ChamsOutlineColor = Color3.new(1, 1, 1),
    ChamsOutlineTransparency = 0,
    
    WireframeEnabled = false,
    WireframeColor = Color3.new(0.403922, 0.34902, 0.701961),
    WireframeThickness = 1,
    WireframeCrossEnabled = true,
    
    RingEnabled = false,
    RingColor = Color3.fromRGB(255, 255, 255),
    RingScanSpeed = 2.5,
    RingScanHeight = 3.5,
    RingRadius = 2.5,
    
    WeaponEnabled = false,
    WeaponColor = Color3.fromRGB(255, 200, 100),
    WeaponSize = 12,
    
    FlagsEnabled = false,
    FlagSize = 12,
    FlagColor = Color3.new(1, 1, 1),
    
    LookDirectionEnabled = false,
    LookDirectionColor = Color3.new(1, 0, 0),
    LookDirectionLength = 100,
    LookDirectionThickness = 1,
    
    OffscreenArrowsEnabled = false,
    OffscreenArrowColor = Color3.new(1, 0, 0),
    OffscreenArrowSize = 15,
    OffscreenArrowRadius = 200,
    
    PositionLerpSpeed = 0.25,
    HealthLerpSpeed = 0.15,
    ColorLerpSpeed = 0.1,
    
    RainbowSpeed = 1,
    
    MaxRenderDistance = 500
}

espModule.Caches = {
    BoxCache = {},
    Box3DCache = {},
    SkeletonCache = {},
    TracerCache = {},
    HeadDotCache = {},
    ChamsCache = {},
    WireframeCache = {},
    RingCache = {},
    LookDirectionCache = {},
    OffscreenCache = {}
}

local localPlayer = playersService.LocalPlayer
local currentCamera = workspaceService.CurrentCamera
local renderConnection = nil
local rainbowHue = 0

local BODY_PARTS = {
    "Head", "Torso", "UpperTorso", "LowerTorso",
    "Left Arm", "Right Arm", "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand",
    "Left Leg", "Right Leg", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot"
}

local CUBE_EDGES = {
    {1, 2}, {2, 3}, {3, 4}, {4, 1},
    {5, 6}, {6, 7}, {7, 8}, {8, 5},
    {1, 5}, {2, 6}, {3, 7}, {4, 8}
}

local CUBE_CROSS = {
    {1, 3}, {2, 4},
    {5, 7}, {6, 8},
    {1, 6}, {2, 5},
    {4, 7}, {3, 8},
    {1, 8}, {4, 5},
    {2, 7}, {3, 6}
}

local function safeCall(callback)
    local success, errorMessage = pcall(callback)
    if not success then
        warn("ESP Error: " .. tostring(errorMessage))
    end
end

local function lerp(a, b, t)
    return a + (b - a) * math.clamp(t, 0, 1)
end

local function lerpVector2(a, b, t)
    return Vector2.new(lerp(a.X, b.X, t), lerp(a.Y, b.Y, t))
end

local function lerpColor3(a, b, t)
    return Color3.new(lerp(a.R, b.R, t), lerp(a.G, b.G, t), lerp(a.B, b.B, t))
end

local function getRainbowColor(offset)
    offset = offset or 0
    local hue = (rainbowHue + offset) % 1
    return Color3.fromHSV(hue, 1, 1)
end

local function getHealthColor(healthPercent, config)
    if healthPercent > 50 then
        local t = (healthPercent - 50) / 50
        return lerpColor3(config.HealthColorMid, config.HealthColorFull, t)
    else
        local t = healthPercent / 50
        return lerpColor3(config.HealthColorLow, config.HealthColorMid, t)
    end
end

local function getCameraDistance(position)
    return (currentCamera.CFrame.Position - position).Magnitude
end

local function worldToScreen(position)
    local screenPos, onScreen = currentCamera:WorldToViewportPoint(position)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen, screenPos.Z
end

local function isTeammate(self, player)
    if not self.Config.TeamCheck then return false end
    if not localPlayer.Team then return false end
    if not player.Team then return false end
    return player.Team == localPlayer.Team
end

local function isVisible(origin, target)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {localPlayer.Character, target.Parent}
    
    local result = workspaceService:Raycast(origin, (target.Position - origin), params)
    return result == nil
end

local function isValidTarget(self, player)
    if player == localPlayer then return false end
    
    local character = player.Character
    if not character then return false end
    
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return false end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    
    local distance = getCameraDistance(root.Position)
    if distance > self.Config.ESPDistance then return false end
    
    if isTeammate(self, player) then return false end
    
    if self.Config.VisibilityCheck then
        local head = character:FindFirstChild("Head")
        if head and not isVisible(currentCamera.CFrame.Position, head) then
            return false
        end
    end
    
    return true
end

local function getBoxCorners(part)
    local cf = part.CFrame
    local size = part.Size
    local sx, sy, sz = size.X / 2, size.Y / 2, size.Z / 2
    
    return {
        cf * CFrame.new(-sx, -sy, -sz),
        cf * CFrame.new(sx, -sy, -sz),
        cf * CFrame.new(sx, -sy, sz),
        cf * CFrame.new(-sx, -sy, sz),
        cf * CFrame.new(-sx, sy, -sz),
        cf * CFrame.new(sx, sy, -sz),
        cf * CFrame.new(sx, sy, sz),
        cf * CFrame.new(-sx, sy, sz)
    }
end

local function getCharacterCorners(character)
    local root = character:FindFirstChild("HumanoidRootPart")
    local head = character:FindFirstChild("Head")
    if not root then return nil end
    
    local cf = root.CFrame
    local headOffset = head and (head.Position.Y - root.Position.Y + 0.5) or 2
    local footOffset = 3
    
    local sx, sz = 2, 1.5
    
    return {
        cf * CFrame.new(-sx, -footOffset, -sz),
        cf * CFrame.new(sx, -footOffset, -sz),
        cf * CFrame.new(sx, -footOffset, sz),
        cf * CFrame.new(-sx, -footOffset, sz),
        cf * CFrame.new(-sx, headOffset, -sz),
        cf * CFrame.new(sx, headOffset, -sz),
        cf * CFrame.new(sx, headOffset, sz),
        cf * CFrame.new(-sx, headOffset, sz)
    }
end

local function getEquippedWeapon(character)
    local tool = character:FindFirstChildOfClass("Tool")
    if tool then
        local cleanName = tool.Name:gsub("%[.-%]", ""):gsub("^%s*(.-)%s*$", "%1")
        return cleanName ~= "" and cleanName or tool.Name
    end
    return nil
end

local function createDrawing(type, properties)
    local drawing = Drawing.new(type)
    for prop, value in pairs(properties or {}) do
        drawing[prop] = value
    end
    return drawing
end

function espModule:CreateBoxCache(player)
    local cache = {
        Box = createDrawing("Square", {Thickness = 1, Filled = false, Visible = false}),
        BoxOutline = createDrawing("Square", {Thickness = 3, Filled = false, Visible = false}),
        BoxFill = createDrawing("Square", {Filled = true, Visible = false}),
        
        TopLeft = createDrawing("Line", {Visible = false}),
        TopRight = createDrawing("Line", {Visible = false}),
        BottomLeft = createDrawing("Line", {Visible = false}),
        BottomRight = createDrawing("Line", {Visible = false}),
        TopLeftV = createDrawing("Line", {Visible = false}),
        TopRightV = createDrawing("Line", {Visible = false}),
        BottomLeftV = createDrawing("Line", {Visible = false}),
        BottomRightV = createDrawing("Line", {Visible = false}),
        
        TopLeftO = createDrawing("Line", {Visible = false, Color = Color3.new(0, 0, 0)}),
        TopRightO = createDrawing("Line", {Visible = false, Color = Color3.new(0, 0, 0)}),
        BottomLeftO = createDrawing("Line", {Visible = false, Color = Color3.new(0, 0, 0)}),
        BottomRightO = createDrawing("Line", {Visible = false, Color = Color3.new(0, 0, 0)}),
        TopLeftVO = createDrawing("Line", {Visible = false, Color = Color3.new(0, 0, 0)}),
        TopRightVO = createDrawing("Line", {Visible = false, Color = Color3.new(0, 0, 0)}),
        BottomLeftVO = createDrawing("Line", {Visible = false, Color = Color3.new(0, 0, 0)}),
        BottomRightVO = createDrawing("Line", {Visible = false, Color = Color3.new(0, 0, 0)}),
        
        Name = createDrawing("Text", {Center = true, Outline = true, Font = 2, Visible = false}),
        Distance = createDrawing("Text", {Center = true, Outline = true, Font = 2, Visible = false}),
        Weapon = createDrawing("Text", {Center = true, Outline = true, Font = 2, Visible = false}),
        Flags = createDrawing("Text", {Outline = true, Font = 2, Visible = false}),
        
        HealthBarBg = createDrawing("Square", {Filled = true, Visible = false, Color = Color3.fromRGB(30, 30, 30)}),
        HealthBar = createDrawing("Square", {Filled = true, Visible = false}),
        HealthBarOutline = createDrawing("Square", {Filled = false, Visible = false, Color = Color3.new(0, 0, 0)}),
        HealthText = createDrawing("Text", {Outline = true, Font = 2, Visible = false}),
        
        ArmorBarBg = createDrawing("Square", {Filled = true, Visible = false, Color = Color3.fromRGB(30, 30, 30)}),
        ArmorBar = createDrawing("Square", {Filled = true, Visible = false}),
        ArmorBarOutline = createDrawing("Square", {Filled = false, Visible = false, Color = Color3.new(0, 0, 0)}),
        
        CurrentPos = Vector2.new(0, 0),
        CurrentSize = Vector2.new(0, 0),
        CurrentHealth = 100,
        CurrentArmor = 0,
        CurrentHealthColor = self.Config.HealthColorFull,
        Initialized = false
    }
    return cache
end

function espModule:CreateBox3DCache(player)
    local cache = {Lines = {}}
    for i = 1, 12 do
        cache.Lines[i] = createDrawing("Line", {Visible = false})
    end
    return cache
end

function espModule:CreateSkeletonCache(player)
    local character = player.Character
    local isR6 = character and character:FindFirstChild("Torso") and not character:FindFirstChild("UpperTorso")
    
    local cache = {IsR6 = isR6, Lines = {}, CurrentPos = {}, Initialized = false}
    
    local lineCount = isR6 and 5 or 14
    for i = 1, lineCount do
        cache.Lines[i] = createDrawing("Line", {Visible = false})
        cache.CurrentPos[i] = {from = Vector2.new(0, 0), to = Vector2.new(0, 0)}
    end
    
    return cache
end

function espModule:CreateTracerCache(player)
    return {
        Line = createDrawing("Line", {Visible = false}),
        Outline = createDrawing("Line", {Visible = false, Color = Color3.new(0, 0, 0)}),
        CurrentFrom = Vector2.new(0, 0),
        CurrentTo = Vector2.new(0, 0),
        Initialized = false
    }
end

function espModule:CreateHeadDotCache(player)
    return {
        Dot = createDrawing("Circle", {Visible = false}),
        Outline = createDrawing("Circle", {Visible = false, Filled = false}),
        CurrentPos = Vector2.new(0, 0),
        Initialized = false
    }
end

function espModule:CreateChamsCache(player)
    local character = player.Character
    if not character then return nil end
    
    local highlight = Instance.new("Highlight")
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Adornee = character
    highlight.Parent = character
    return highlight
end

function espModule:CreateWireframeCache(player)
    local cache = {Lines = {}}
    local totalLines = self.Config.WireframeCrossEnabled and 24 or 12
    
    for _, partName in ipairs(BODY_PARTS) do
        cache.Lines[partName] = {}
        for i = 1, totalLines do
            cache.Lines[partName][i] = createDrawing("Line", {Visible = false})
        end
    end
    
    return cache
end

function espModule:CreateRingCache(player)
    if player == localPlayer then return nil end
    
    local holder = Instance.new("Part")
    holder.Name = "ESP_Ring_" .. player.Name
    holder.Transparency = 1
    holder.CanCollide = false
    holder.Anchored = true
    holder.Parent = workspaceService
    
    local ring = Instance.new("CylinderHandleAdornment")
    ring.Adornee = holder
    ring.AlwaysOnTop = true
    ring.ZIndex = 10
    ring.Height = 0.08
    ring.CFrame = CFrame.Angles(math.rad(90), 0, 0)
    ring.Parent = holder
    ring.Visible = false
    
    return {Holder = holder, Ring = ring, Root = nil}
end

function espModule:CreateLookDirectionCache(player)
    return {
        Line = createDrawing("Line", {Visible = false}),
        CurrentFrom = Vector2.new(0, 0),
        CurrentTo = Vector2.new(0, 0),
        Initialized = false
    }
end

function espModule:CreateOffscreenCache(player)
    return {
        Arrow = createDrawing("Triangle", {Filled = true, Visible = false}),
        Outline = createDrawing("Triangle", {Filled = false, Visible = false, Color = Color3.new(0, 0, 0)})
    }
end

function espModule:ClearCache(cacheName, player)
    local cache = self.Caches[cacheName][player]
    if not cache then return end
    
    if cacheName == "BoxCache" then
        for _, drawing in pairs(cache) do
            if typeof(drawing) == "table" and drawing.Remove then
                pcall(function() drawing:Remove() end)
            end
        end
    elseif cacheName == "Box3DCache" then
        for _, line in ipairs(cache.Lines) do
            pcall(function() line:Remove() end)
        end
    elseif cacheName == "SkeletonCache" then
        for _, line in ipairs(cache.Lines) do
            pcall(function() line:Remove() end)
        end
    elseif cacheName == "TracerCache" then
        pcall(function() cache.Line:Remove() end)
        pcall(function() cache.Outline:Remove() end)
    elseif cacheName == "HeadDotCache" then
        pcall(function() cache.Dot:Remove() end)
        pcall(function() cache.Outline:Remove() end)
    elseif cacheName == "ChamsCache" then
        pcall(function() cache:Destroy() end)
    elseif cacheName == "WireframeCache" then
        for _, lines in pairs(cache.Lines) do
            for _, line in ipairs(lines) do
                pcall(function() line:Remove() end)
            end
        end
    elseif cacheName == "RingCache" then
        pcall(function() cache.Holder:Destroy() end)
    elseif cacheName == "LookDirectionCache" then
        pcall(function() cache.Line:Remove() end)
    elseif cacheName == "OffscreenCache" then
        pcall(function() cache.Arrow:Remove() end)
        pcall(function() cache.Outline:Remove() end)
    end
    
    self.Caches[cacheName][player] = nil
end

function espModule:ClearAllCaches(cacheName)
    for player, _ in pairs(self.Caches[cacheName]) do
        self:ClearCache(cacheName, player)
    end
end

function espModule:HideBoxCache(player)
    local cache = self.Caches.BoxCache[player]
    if not cache then return end
    
    for key, drawing in pairs(cache) do
        if typeof(drawing) == "table" and drawing.Visible ~= nil then
            drawing.Visible = false
        end
    end
end

function espModule:UpdateBox(dt)
    local shouldDraw = self.Config.BoxEnabled or self.Config.NameEnabled or 
                       self.Config.DistanceEnabled or self.Config.HealthBarEnabled or 
                       self.Config.HealthTextEnabled or self.Config.ArmorBarEnabled or
                       self.Config.WeaponEnabled or self.Config.FlagsEnabled
    
    if not shouldDraw then
        self:ClearAllCaches("BoxCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("BoxCache")
        return
    end
    
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    local healthLerp = math.clamp(self.Config.HealthLerpSpeed * dt * 60, 0, 1)
    local colorLerp = math.clamp(self.Config.ColorLerpSpeed * dt * 60, 0, 1)
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                if not isValidTarget(self, player) then
                    self:ClearCache("BoxCache", player)
                    return
                end
                
                local character = player.Character
                local root = character:FindFirstChild("HumanoidRootPart")
                local head = character:FindFirstChild("Head")
                local humanoid = character:FindFirstChild("Humanoid")
                local distance = getCameraDistance(root.Position)
                
                if not self.Caches.BoxCache[player] then
                    self.Caches.BoxCache[player] = self:CreateBoxCache(player)
                end
                
                local cache = self.Caches.BoxCache[player]
                local rootScreen, onScreen = worldToScreen(root.Position)
                
                if not onScreen then
                    self:HideBoxCache(player)
                    return
                end
                
                local headTop = head and (head.Position + Vector3.new(0, 0.8, 0)) or (root.Position + Vector3.new(0, 2.5, 0))
                local feet = root.Position - Vector3.new(0, 3, 0)
                
                local headScreen = worldToScreen(headTop)
                local feetScreen = worldToScreen(feet)
                
                local height = math.abs(headScreen.Y - feetScreen.Y)
                local width = height * 0.5
                
                local center = Vector2.new(rootScreen.X, (headScreen.Y + feetScreen.Y) / 2)
                local targetPos = center - Vector2.new(width / 2, height / 2)
                local targetSize = Vector2.new(width, height)
                
                if not cache.Initialized then
                    cache.CurrentPos = targetPos
                    cache.CurrentSize = targetSize
                    cache.Initialized = true
                else
                    cache.CurrentPos = lerpVector2(cache.CurrentPos, targetPos, posLerp)
                    cache.CurrentSize = lerpVector2(cache.CurrentSize, targetSize, posLerp)
                end
                
                local pos = cache.CurrentPos
                local size = cache.CurrentSize
                local centerX = pos.X + size.X / 2
                
                local healthPercent = (humanoid.Health / humanoid.MaxHealth) * 100
                cache.CurrentHealth = lerp(cache.CurrentHealth, healthPercent, healthLerp)
                
                local targetHealthColor = getHealthColor(cache.CurrentHealth, self.Config)
                cache.CurrentHealthColor = lerpColor3(cache.CurrentHealthColor, targetHealthColor, colorLerp)
                
                local bodyEffects = character:FindFirstChild("BodyEffects")
                local armorVal = bodyEffects and bodyEffects:FindFirstChild("Armor") and bodyEffects.Armor.Value or 0
                local armorPercent = math.clamp((armorVal / 200) * 100, 0, 100)
                cache.CurrentArmor = lerp(cache.CurrentArmor, armorPercent, healthLerp)
                
                local boxColor = self.Config.BoxRainbow and getRainbowColor() or self.Config.BoxColor
                
                if self.Config.BoxEnabled then
                    if self.Config.BoxStyle == "Full" then
                        cache.Box.Visible = true
                        cache.Box.Position = pos
                        cache.Box.Size = size
                        cache.Box.Color = boxColor
                        cache.Box.Thickness = self.Config.BoxThickness
                        
                        if self.Config.BoxOutlineEnabled then
                            cache.BoxOutline.Visible = true
                            cache.BoxOutline.Position = pos
                            cache.BoxOutline.Size = size
                            cache.BoxOutline.Color = self.Config.BoxOutlineColor
                            cache.BoxOutline.Thickness = self.Config.BoxThickness + 2
                        else
                            cache.BoxOutline.Visible = false
                        end
                        
                        if self.Config.BoxFilled then
                            cache.BoxFill.Visible = true
                            cache.BoxFill.Position = pos
                            cache.BoxFill.Size = size
                            cache.BoxFill.Color = boxColor
                            cache.BoxFill.Transparency = self.Config.BoxFillTransparency
                        else
                            cache.BoxFill.Visible = false
                        end
                        
                        for _, key in ipairs({"TopLeft", "TopRight", "BottomLeft", "BottomRight", "TopLeftV", "TopRightV", "BottomLeftV", "BottomRightV"}) do
                            cache[key].Visible = false
                            cache[key .. "O"].Visible = false
                        end
                        
                    elseif self.Config.BoxStyle == "Corner" then
                        cache.Box.Visible = false
                        cache.BoxOutline.Visible = false
                        cache.BoxFill.Visible = false
                        
                        local cornerLen = size.X * self.Config.CornerLength
                        local cornerLenV = size.Y * self.Config.CornerLength
                        local thickness = self.Config.BoxThickness
                        
                        cache.TopLeft.From = pos
                        cache.TopLeft.To = pos + Vector2.new(cornerLen, 0)
                        cache.TopLeft.Color = boxColor
                        cache.TopLeft.Thickness = thickness
                        cache.TopLeft.Visible = true
                        
                        cache.TopLeftV.From = pos
                        cache.TopLeftV.To = pos + Vector2.new(0, cornerLenV)
                        cache.TopLeftV.Color = boxColor
                        cache.TopLeftV.Thickness = thickness
                        cache.TopLeftV.Visible = true
                        
                        cache.TopRight.From = pos + Vector2.new(size.X, 0)
                        cache.TopRight.To = pos + Vector2.new(size.X - cornerLen, 0)
                        cache.TopRight.Color = boxColor
                        cache.TopRight.Thickness = thickness
                        cache.TopRight.Visible = true
                        
                        cache.TopRightV.From = pos + Vector2.new(size.X, 0)
                        cache.TopRightV.To = pos + Vector2.new(size.X, cornerLenV)
                        cache.TopRightV.Color = boxColor
                        cache.TopRightV.Thickness = thickness
                        cache.TopRightV.Visible = true
                        
                        cache.BottomLeft.From = pos + Vector2.new(0, size.Y)
                        cache.BottomLeft.To = pos + Vector2.new(cornerLen, size.Y)
                        cache.BottomLeft.Color = boxColor
                        cache.BottomLeft.Thickness = thickness
                        cache.BottomLeft.Visible = true
                        
                        cache.BottomLeftV.From = pos + Vector2.new(0, size.Y)
                        cache.BottomLeftV.To = pos + Vector2.new(0, size.Y - cornerLenV)
                        cache.BottomLeftV.Color = boxColor
                        cache.BottomLeftV.Thickness = thickness
                        cache.BottomLeftV.Visible = true
                        
                        cache.BottomRight.From = pos + Vector2.new(size.X, size.Y)
                        cache.BottomRight.To = pos + Vector2.new(size.X - cornerLen, size.Y)
                        cache.BottomRight.Color = boxColor
                        cache.BottomRight.Thickness = thickness
                        cache.BottomRight.Visible = true
                        
                        cache.BottomRightV.From = pos + Vector2.new(size.X, size.Y)
                        cache.BottomRightV.To = pos + Vector2.new(size.X, size.Y - cornerLenV)
                        cache.BottomRightV.Color = boxColor
                        cache.BottomRightV.Thickness = thickness
                        cache.BottomRightV.Visible = true
                        
                        if self.Config.BoxOutlineEnabled then
                            for _, key in ipairs({"TopLeft", "TopRight", "BottomLeft", "BottomRight", "TopLeftV", "TopRightV", "BottomLeftV", "BottomRightV"}) do
                                cache[key .. "O"].From = cache[key].From
                                cache[key .. "O"].To = cache[key].To
                                cache[key .. "O"].Thickness = thickness + 2
                                cache[key .. "O"].Visible = true
                            end
                        else
                            for _, key in ipairs({"TopLeftO", "TopRightO", "BottomLeftO", "BottomRightO", "TopLeftVO", "TopRightVO", "BottomLeftVO", "BottomRightVO"}) do
                                cache[key].Visible = false
                            end
                        end
                    end
                else
                    cache.Box.Visible = false
                    cache.BoxOutline.Visible = false
                    cache.BoxFill.Visible = false
                    for _, key in ipairs({"TopLeft", "TopRight", "BottomLeft", "BottomRight", "TopLeftV", "TopRightV", "BottomLeftV", "BottomRightV"}) do
                        cache[key].Visible = false
                        cache[key .. "O"].Visible = false
                    end
                end
                
                local textY = pos.Y - 2
                
                if self.Config.NameEnabled then
                    textY = textY - self.Config.NameSize - 2
                    cache.Name.Visible = true
                    cache.Name.Position = Vector2.new(centerX, textY)
                    cache.Name.Text = self.Config.ShowDisplayName and player.DisplayName or player.Name
                    cache.Name.Color = self.Config.NameColor
                    cache.Name.Size = self.Config.NameSize
                else
                    cache.Name.Visible = false
                end
                
                local bottomY = pos.Y + size.Y + 2
                
                if self.Config.DistanceEnabled then
                    cache.Distance.Visible = true
                    cache.Distance.Position = Vector2.new(centerX, bottomY)
                    cache.Distance.Text = math.floor(distance) .. "m"
                    cache.Distance.Color = self.Config.DistanceColor
                    cache.Distance.Size = self.Config.DistanceSize
                    bottomY = bottomY + self.Config.DistanceSize + 2
                else
                    cache.Distance.Visible = false
                end
                
                if self.Config.WeaponEnabled then
                    local weapon = getEquippedWeapon(character)
                    if weapon then
                        cache.Weapon.Visible = true
                        cache.Weapon.Position = Vector2.new(centerX, bottomY)
                        cache.Weapon.Text = weapon
                        cache.Weapon.Color = self.Config.WeaponColor
                        cache.Weapon.Size = self.Config.WeaponSize
                        bottomY = bottomY + self.Config.WeaponSize + 2
                    else
                        cache.Weapon.Visible = false
                    end
                else
                    cache.Weapon.Visible = false
                end
                
                if self.Config.FlagsEnabled then
                    local flags = {}
                    if humanoid.Health < humanoid.MaxHealth * 0.3 then table.insert(flags, "LOW HP") end
                    if armorVal > 0 then table.insert(flags, "ARMOR") end
                    local weapon = getEquippedWeapon(character)
                    if weapon then table.insert(flags, weapon) end
                    
                    if #flags > 0 then
                        cache.Flags.Visible = true
                        cache.Flags.Position = Vector2.new(pos.X + size.X + 4, pos.Y)
                        cache.Flags.Text = table.concat(flags, "\n")
                        cache.Flags.Color = self.Config.FlagColor
                        cache.Flags.Size = self.Config.FlagSize
                    else
                        cache.Flags.Visible = false
                    end
                else
                    cache.Flags.Visible = false
                end
                
                if self.Config.HealthBarEnabled then
                    local barWidth = self.Config.HealthBarWidth
                    local barHeight = size.Y * (cache.CurrentHealth / 100)
                    local barX
                    
                    if self.Config.HealthBarPosition == "Left" then
                        barX = pos.X - barWidth - 4
                    else
                        barX = pos.X + size.X + 2
                    end
                    
                    cache.HealthBarBg.Visible = true
                    cache.HealthBarBg.Position = Vector2.new(barX, pos.Y)
                    cache.HealthBarBg.Size = Vector2.new(barWidth, size.Y)
                    
                    cache.HealthBar.Visible = true
                    cache.HealthBar.Position = Vector2.new(barX, pos.Y + size.Y - barHeight)
                    cache.HealthBar.Size = Vector2.new(barWidth, barHeight)
                    cache.HealthBar.Color = cache.CurrentHealthColor
                    
                    if self.Config.HealthBarOutline then
                        cache.HealthBarOutline.Visible = true
                        cache.HealthBarOutline.Position = Vector2.new(barX - 1, pos.Y - 1)
                        cache.HealthBarOutline.Size = Vector2.new(barWidth + 2, size.Y + 2)
                    else
                        cache.HealthBarOutline.Visible = false
                    end
                    
                    if self.Config.HealthTextEnabled and cache.CurrentHealth < 100 then
                        cache.HealthText.Visible = true
                        cache.HealthText.Position = Vector2.new(barX - 15, pos.Y + size.Y - barHeight - 6)
                        cache.HealthText.Text = tostring(math.floor(cache.CurrentHealth))
                        cache.HealthText.Color = cache.CurrentHealthColor
                        cache.HealthText.Size = self.Config.HealthTextSize
                    else
                        cache.HealthText.Visible = false
                    end
                else
                    cache.HealthBarBg.Visible = false
                    cache.HealthBar.Visible = false
                    cache.HealthBarOutline.Visible = false
                    cache.HealthText.Visible = false
                end
                
                if self.Config.ArmorBarEnabled and cache.CurrentArmor > 0 then
                    local barWidth = self.Config.ArmorBarWidth
                    local barHeight = size.Y * (cache.CurrentArmor / 100)
                    local barX
                    
                    if self.Config.ArmorBarPosition == "Right" then
                        barX = pos.X + size.X + 2
                        if self.Config.HealthBarEnabled and self.Config.HealthBarPosition == "Right" then
                            barX = barX + self.Config.HealthBarWidth + 4
                        end
                    else
                        barX = pos.X - barWidth - 4
                        if self.Config.HealthBarEnabled and self.Config.HealthBarPosition == "Left" then
                            barX = barX - self.Config.HealthBarWidth - 4
                        end
                    end
                    
                    cache.ArmorBarBg.Visible = true
                    cache.ArmorBarBg.Position = Vector2.new(barX, pos.Y)
                    cache.ArmorBarBg.Size = Vector2.new(barWidth, size.Y)
                    
                    cache.ArmorBar.Visible = true
                    cache.ArmorBar.Position = Vector2.new(barX, pos.Y + size.Y - barHeight)
                    cache.ArmorBar.Size = Vector2.new(barWidth, barHeight)
                    cache.ArmorBar.Color = self.Config.ArmorBarColor
                    
                    cache.ArmorBarOutline.Visible = true
                    cache.ArmorBarOutline.Position = Vector2.new(barX - 1, pos.Y - 1)
                    cache.ArmorBarOutline.Size = Vector2.new(barWidth + 2, size.Y + 2)
                else
                    cache.ArmorBarBg.Visible = false
                    cache.ArmorBar.Visible = false
                    cache.ArmorBarOutline.Visible = false
                end
            end)
            
            if not success then
                self:ClearCache("BoxCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.BoxCache) do
        if not activePlayers[player] then
            self:ClearCache("BoxCache", player)
        end
    end
end

function espModule:UpdateBox3D()
    if not self.Config.Box3DEnabled then
        self:ClearAllCaches("Box3DCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("Box3DCache")
        return
    end
    
    local activePlayers = {}
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                if not isValidTarget(self, player) then
                    self:ClearCache("Box3DCache", player)
                    return
                end
                
                local character = player.Character
                local corners = getCharacterCorners(character)
                if not corners then
                    self:ClearCache("Box3DCache", player)
                    return
                end
                
                if not self.Caches.Box3DCache[player] then
                    self.Caches.Box3DCache[player] = self:CreateBox3DCache(player)
                end
                
                local cache = self.Caches.Box3DCache[player]
                local screenCorners = {}
                local allVisible = true
                
                for i, corner in ipairs(corners) do
                    local screen, onScreen, depth = worldToScreen(corner.Position)
                    screenCorners[i] = {pos = screen, visible = onScreen and depth > 0}
                    if depth < 0 then allVisible = false end
                end
                
                if allVisible then
                    for i, edge in ipairs(CUBE_EDGES) do
                        local c1, c2 = screenCorners[edge[1]], screenCorners[edge[2]]
                        local line = cache.Lines[i]
                        
                        if c1.visible and c2.visible then
                            line.From = c1.pos
                            line.To = c2.pos
                            line.Color = self.Config.Box3DColor
                            line.Thickness = self.Config.Box3DThickness
                            line.Visible = true
                        else
                            line.Visible = false
                        end
                    end
                else
                    for i = 1, 12 do
                        cache.Lines[i].Visible = false
                    end
                end
            end)
            
            if not success then
                self:ClearCache("Box3DCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.Box3DCache) do
        if not activePlayers[player] then
            self:ClearCache("Box3DCache", player)
        end
    end
end

function espModule:UpdateSkeleton(dt)
    if not self.Config.SkeletonEnabled then
        self:ClearAllCaches("SkeletonCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("SkeletonCache")
        return
    end
    
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    
    local r6Connections = {
        {"Head", "Torso"},
        {"Torso", "Left Arm"},
        {"Torso", "Right Arm"},
        {"Torso", "Left Leg"},
        {"Torso", "Right Leg"}
    }
    
    local r15Connections = {
        {"Head", "UpperTorso"},
        {"UpperTorso", "LowerTorso"},
        {"UpperTorso", "LeftUpperArm"},
        {"LeftUpperArm", "LeftLowerArm"},
        {"LeftLowerArm", "LeftHand"},
        {"UpperTorso", "RightUpperArm"},
        {"RightUpperArm", "RightLowerArm"},
        {"RightLowerArm", "RightHand"},
        {"LowerTorso", "LeftUpperLeg"},
        {"LeftUpperLeg", "LeftLowerLeg"},
        {"LeftLowerLeg", "LeftFoot"},
        {"LowerTorso", "RightUpperLeg"},
        {"RightUpperLeg", "RightLowerLeg"},
        {"RightLowerLeg", "RightFoot"}
    }
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                if not isValidTarget(self, player) then
                    self:ClearCache("SkeletonCache", player)
                    return
                end
                
                local character = player.Character
                
                if not self.Caches.SkeletonCache[player] then
                    self.Caches.SkeletonCache[player] = self:CreateSkeletonCache(player)
                end
                
                local cache = self.Caches.SkeletonCache[player]
                local connections = cache.IsR6 and r6Connections or r15Connections
                
                for i, conn in ipairs(connections) do
                    local part1 = character:FindFirstChild(conn[1])
                    local part2 = character:FindFirstChild(conn[2])
                    
                    if part1 and part2 then
                        local screen1, on1 = worldToScreen(part1.Position)
                        local screen2, on2 = worldToScreen(part2.Position)
                        
                        if on1 and on2 then
                            if not cache.Initialized then
                                cache.CurrentPos[i].from = screen1
                                cache.CurrentPos[i].to = screen2
                            else
                                cache.CurrentPos[i].from = lerpVector2(cache.CurrentPos[i].from, screen1, posLerp)
                                cache.CurrentPos[i].to = lerpVector2(cache.CurrentPos[i].to, screen2, posLerp)
                            end
                            
                            cache.Lines[i].From = cache.CurrentPos[i].from
                            cache.Lines[i].To = cache.CurrentPos[i].to
                            cache.Lines[i].Color = self.Config.SkeletonColor
                            cache.Lines[i].Thickness = self.Config.SkeletonThickness
                            cache.Lines[i].Visible = true
                        else
                            cache.Lines[i].Visible = false
                        end
                    else
                        cache.Lines[i].Visible = false
                    end
                end
                
                cache.Initialized = true
            end)
            
            if not success then
                self:ClearCache("SkeletonCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.SkeletonCache) do
        if not activePlayers[player] then
            self:ClearCache("SkeletonCache", player)
        end
    end
end

function espModule:UpdateTracer(dt)
    if not self.Config.TracerEnabled then
        self:ClearAllCaches("TracerCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("TracerCache")
        return
    end
    
    local viewportSize = currentCamera.ViewportSize
    local origin
    
    if self.Config.TracerOrigin == "Bottom" then
        origin = Vector2.new(viewportSize.X / 2, viewportSize.Y)
    elseif self.Config.TracerOrigin == "Top" then
        origin = Vector2.new(viewportSize.X / 2, 0)
    elseif self.Config.TracerOrigin == "Center" then
        origin = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    elseif self.Config.TracerOrigin == "Mouse" then
        origin = userInputService:GetMouseLocation()
    end
    
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                if not isValidTarget(self, player) then
                    self:ClearCache("TracerCache", player)
                    return
                end
                
                local character = player.Character
                local root = character:FindFirstChild("HumanoidRootPart")
                
                if not self.Caches.TracerCache[player] then
                    self.Caches.TracerCache[player] = self:CreateTracerCache(player)
                end
                
                local cache = self.Caches.TracerCache[player]
                local targetScreen, onScreen = worldToScreen(root.Position)
                
                if not cache.Initialized then
                    cache.CurrentFrom = origin
                    cache.CurrentTo = targetScreen
                    cache.Initialized = true
                else
                    cache.CurrentFrom = lerpVector2(cache.CurrentFrom, origin, posLerp)
                    cache.CurrentTo = lerpVector2(cache.CurrentTo, targetScreen, posLerp)
                end
                
                if self.Config.TracerOutline then
                    cache.Outline.From = cache.CurrentFrom
                    cache.Outline.To = cache.CurrentTo
                    cache.Outline.Thickness = self.Config.TracerThickness + 2
                    cache.Outline.Color = self.Config.TracerOutlineColor
                    cache.Outline.Visible = onScreen
                else
                    cache.Outline.Visible = false
                end
                
                cache.Line.From = cache.CurrentFrom
                cache.Line.To = cache.CurrentTo
                cache.Line.Color = self.Config.TracerColor
                cache.Line.Thickness = self.Config.TracerThickness
                cache.Line.Visible = onScreen
            end)
            
            if not success then
                self:ClearCache("TracerCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.TracerCache) do
        if not activePlayers[player] then
            self:ClearCache("TracerCache", player)
        end
    end
end

function espModule:UpdateHeadDot(dt)
    if not self.Config.HeadDotEnabled then
        self:ClearAllCaches("HeadDotCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("HeadDotCache")
        return
    end
    
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                if not isValidTarget(self, player) then
                    self:ClearCache("HeadDotCache", player)
                    return
                end
                
                local character = player.Character
                local head = character:FindFirstChild("Head")
                if not head then
                    self:ClearCache("HeadDotCache", player)
                    return
                end
                
                if not self.Caches.HeadDotCache[player] then
                    self.Caches.HeadDotCache[player] = self:CreateHeadDotCache(player)
                end
                
                local cache = self.Caches.HeadDotCache[player]
                local headScreen, onScreen = worldToScreen(head.Position)
                
                if not cache.Initialized then
                    cache.CurrentPos = headScreen
                    cache.Initialized = true
                else
                    cache.CurrentPos = lerpVector2(cache.CurrentPos, headScreen, posLerp)
                end
                
                if onScreen then
                    if self.Config.HeadDotOutline then
                        cache.Outline.Position = cache.CurrentPos
                        cache.Outline.Radius = self.Config.HeadDotSize + 1
                        cache.Outline.Color = self.Config.HeadDotOutlineColor
                        cache.Outline.Thickness = 2
                        cache.Outline.Visible = true
                    else
                        cache.Outline.Visible = false
                    end
                    
                    cache.Dot.Position = cache.CurrentPos
                    cache.Dot.Radius = self.Config.HeadDotSize
                    cache.Dot.Color = self.Config.HeadDotColor
                    cache.Dot.Filled = self.Config.HeadDotFilled
                    cache.Dot.Visible = true
                else
                    cache.Dot.Visible = false
                    cache.Outline.Visible = false
                end
            end)
            
            if not success then
                self:ClearCache("HeadDotCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.HeadDotCache) do
        if not activePlayers[player] then
            self:ClearCache("HeadDotCache", player)
        end
    end
end

function espModule:UpdateChams()
    if not self.Config.ChamsEnabled then
        self:ClearAllCaches("ChamsCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("ChamsCache")
        return
    end
    
    local activePlayers = {}
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                if not isValidTarget(self, player) then
                    self:ClearCache("ChamsCache", player)
                    return
                end
                
                if not self.Caches.ChamsCache[player] then
                    self.Caches.ChamsCache[player] = self:CreateChamsCache(player)
                end
                
                local highlight = self.Caches.ChamsCache[player]
                if highlight then
                    highlight.FillColor = self.Config.ChamsColor
                    highlight.OutlineColor = self.Config.ChamsOutlineColor
                    highlight.FillTransparency = self.Config.ChamsFillTransparency
                    highlight.OutlineTransparency = self.Config.ChamsOutlineTransparency
                end
            end)
            
            if not success then
                self:ClearCache("ChamsCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.ChamsCache) do
        if not activePlayers[player] then
            self:ClearCache("ChamsCache", player)
        end
    end
end

function espModule:UpdateWireframe()
    if not self.Config.WireframeEnabled then
        self:ClearAllCaches("WireframeCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("WireframeCache")
        return
    end
    
    local activePlayers = {}
    local edges = self.Config.WireframeCrossEnabled and 24 or 12
    local allEdges = {}
    for _, e in ipairs(CUBE_EDGES) do table.insert(allEdges, e) end
    if self.Config.WireframeCrossEnabled then
        for _, e in ipairs(CUBE_CROSS) do table.insert(allEdges, e) end
    end
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                if not isValidTarget(self, player) then
                    self:ClearCache("WireframeCache", player)
                    return
                end
                
                local character = player.Character
                
                if not self.Caches.WireframeCache[player] then
                    self.Caches.WireframeCache[player] = self:CreateWireframeCache(player)
                end
                
                local cache = self.Caches.WireframeCache[player]
                
                for _, partName in ipairs(BODY_PARTS) do
                    local part = character:FindFirstChild(partName)
                    local lines = cache.Lines[partName]
                    
                    if part and part:IsA("BasePart") and lines then
                        local corners = getBoxCorners(part)
                        local screenCorners = {}
                        local allVisible = true
                        
                        for i, corner in ipairs(corners) do
                            local screen, onScreen, depth = worldToScreen(corner.Position)
                            screenCorners[i] = {pos = screen, visible = onScreen, depth = depth}
                            if depth < 0 then allVisible = false end
                        end
                        
                        if allVisible then
                            for i, edge in ipairs(allEdges) do
                                local line = lines[i]
                                if line then
                                    local c1, c2 = screenCorners[edge[1]], screenCorners[edge[2]]
                                    
                                    if c1.visible and c2.visible then
                                        line.From = c1.pos
                                        line.To = c2.pos
                                        line.Color = self.Config.WireframeColor
                                        line.Thickness = self.Config.WireframeThickness
                                        line.Visible = true
                                    else
                                        line.Visible = false
                                    end
                                end
                            end
                        else
                            for i = 1, edges do
                                if lines[i] then lines[i].Visible = false end
                            end
                        end
                    else
                        if lines then
                            for i = 1, edges do
                                if lines[i] then lines[i].Visible = false end
                            end
                        end
                    end
                end
            end)
            
            if not success then
                self:ClearCache("WireframeCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.WireframeCache) do
        if not activePlayers[player] then
            self:ClearCache("WireframeCache", player)
        end
    end
end

function espModule:UpdateRing()
    if not self.Config.RingEnabled then
        self:ClearAllCaches("RingCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("RingCache")
        return
    end
    
    local t = tick()
    local activePlayers = {}
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                if not isValidTarget(self, player) then
                    self:ClearCache("RingCache", player)
                    return
                end
                
                local character = player.Character
                local root = character:FindFirstChild("HumanoidRootPart")
                
                if not self.Caches.RingCache[player] then
                    self.Caches.RingCache[player] = self:CreateRingCache(player)
                end
                
                local cache = self.Caches.RingCache[player]
                if cache then
                    local yOffset = math.sin(t * self.Config.RingScanSpeed) * self.Config.RingScanHeight
                    cache.Holder.CFrame = root.CFrame * CFrame.new(0, yOffset, 0)
                    cache.Ring.Color3 = self.Config.RingColor
                    cache.Ring.Radius = self.Config.RingRadius
                    cache.Ring.InnerRadius = self.Config.RingRadius - 0.1
                    cache.Ring.Transparency = 0.2 + math.abs(math.sin(t * self.Config.RingScanSpeed)) * 0.4
                    cache.Ring.Visible = true
                end
            end)
            
            if not success then
                self:ClearCache("RingCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.RingCache) do
        if not activePlayers[player] then
            self:ClearCache("RingCache", player)
        end
    end
end

function espModule:UpdateLookDirection(dt)
    if not self.Config.LookDirectionEnabled then
        self:ClearAllCaches("LookDirectionCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("LookDirectionCache")
        return
    end
    
    local activePlayers = {}
    local posLerp = math.clamp(self.Config.PositionLerpSpeed * dt * 60, 0, 1)
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                if not isValidTarget(self, player) then
                    self:ClearCache("LookDirectionCache", player)
                    return
                end
                
                local character = player.Character
                local head = character:FindFirstChild("Head")
                if not head then
                    self:ClearCache("LookDirectionCache", player)
                    return
                end
                
                if not self.Caches.LookDirectionCache[player] then
                    self.Caches.LookDirectionCache[player] = self:CreateLookDirectionCache(player)
                end
                
                local cache = self.Caches.LookDirectionCache[player]
                
                local startPos = head.Position
                local endPos = startPos + head.CFrame.LookVector * self.Config.LookDirectionLength
                
                local startScreen, startOn = worldToScreen(startPos)
                local endScreen, endOn = worldToScreen(endPos)
                
                if startOn then
                    if not cache.Initialized then
                        cache.CurrentFrom = startScreen
                        cache.CurrentTo = endScreen
                        cache.Initialized = true
                    else
                        cache.CurrentFrom = lerpVector2(cache.CurrentFrom, startScreen, posLerp)
                        cache.CurrentTo = lerpVector2(cache.CurrentTo, endScreen, posLerp)
                    end
                    
                    cache.Line.From = cache.CurrentFrom
                    cache.Line.To = cache.CurrentTo
                    cache.Line.Color = self.Config.LookDirectionColor
                    cache.Line.Thickness = self.Config.LookDirectionThickness
                    cache.Line.Visible = true
                else
                    cache.Line.Visible = false
                end
            end)
            
            if not success then
                self:ClearCache("LookDirectionCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.LookDirectionCache) do
        if not activePlayers[player] then
            self:ClearCache("LookDirectionCache", player)
        end
    end
end

function espModule:UpdateOffscreenArrows()
    if not self.Config.OffscreenArrowsEnabled then
        self:ClearAllCaches("OffscreenCache")
        return
    end
    
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        self:ClearAllCaches("OffscreenCache")
        return
    end
    
    local viewportSize = currentCamera.ViewportSize
    local center = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    local activePlayers = {}
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            activePlayers[player] = true
            
            local success = pcall(function()
                local character = player.Character
                if not character then
                    self:ClearCache("OffscreenCache", player)
                    return
                end
                
                local root = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if not root or not humanoid or humanoid.Health <= 0 then
                    self:ClearCache("OffscreenCache", player)
                    return
                end
                
                if isTeammate(self, player) then
                    self:ClearCache("OffscreenCache", player)
                    return
                end
                
                local screenPos, onScreen = worldToScreen(root.Position)
                
                if onScreen then
                    if self.Caches.OffscreenCache[player] then
                        self.Caches.OffscreenCache[player].Arrow.Visible = false
                        self.Caches.OffscreenCache[player].Outline.Visible = false
                    end
                    return
                end
                
                if not self.Caches.OffscreenCache[player] then
                    self.Caches.OffscreenCache[player] = self:CreateOffscreenCache(player)
                end
                
                local cache = self.Caches.OffscreenCache[player]
                
                local direction = (screenPos - center).Unit
                local arrowPos = center + direction * self.Config.OffscreenArrowRadius
                
                local angle = math.atan2(direction.Y, direction.X)
                local size = self.Config.OffscreenArrowSize
                
                local p1 = arrowPos + Vector2.new(math.cos(angle) * size, math.sin(angle) * size)
                local p2 = arrowPos + Vector2.new(math.cos(angle + 2.5) * size * 0.6, math.sin(angle + 2.5) * size * 0.6)
                local p3 = arrowPos + Vector2.new(math.cos(angle - 2.5) * size * 0.6, math.sin(angle - 2.5) * size * 0.6)
                
                cache.Outline.PointA = p1
                cache.Outline.PointB = p2
                cache.Outline.PointC = p3
                cache.Outline.Thickness = 2
                cache.Outline.Visible = true
                
                cache.Arrow.PointA = p1
                cache.Arrow.PointB = p2
                cache.Arrow.PointC = p3
                cache.Arrow.Color = self.Config.OffscreenArrowColor
                cache.Arrow.Visible = true
            end)
            
            if not success then
                self:ClearCache("OffscreenCache", player)
            end
        end
    end
    
    for player, _ in pairs(self.Caches.OffscreenCache) do
        if not activePlayers[player] then
            self:ClearCache("OffscreenCache", player)
        end
    end
end

function espModule:Cleanup()
    for cacheName, _ in pairs(self.Caches) do
        self:ClearAllCaches(cacheName)
    end
end

function espModule:Destroy()
    self:Cleanup()
    
    if renderConnection then
        renderConnection:Disconnect()
        renderConnection = nil
    end
end

function espModule:Initialize()
    playersService.PlayerRemoving:Connect(function(player)
        safeCall(function()
            for cacheName, _ in pairs(self.Caches) do
                self:ClearCache(cacheName, player)
            end
        end)
    end)
    
    for _, player in ipairs(playersService:GetPlayers()) do
        if player ~= localPlayer then
            player.CharacterAdded:Connect(function()
                safeCall(function()
                    for cacheName, _ in pairs(self.Caches) do
                        self:ClearCache(cacheName, player)
                    end
                end)
            end)
        end
    end
    
    playersService.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(function(character)
            safeCall(function()
                for cacheName, _ in pairs(self.Caches) do
                    self:ClearCache(cacheName, player)
                end
            end)
            
            local humanoid = character:WaitForChild("Humanoid", 5)
            if humanoid then
                humanoid.Died:Connect(function()
                    safeCall(function()
                        for cacheName, _ in pairs(self.Caches) do
                            self:ClearCache(cacheName, player)
                        end
                    end)
                end)
            end
        end)
    end)
    
    renderConnection = runService.RenderStepped:Connect(function(dt)
        rainbowHue = (rainbowHue + self.Config.RainbowSpeed * dt * 0.1) % 1
        
        safeCall(function() self:UpdateBox(dt) end)
        safeCall(function() self:UpdateBox3D() end)
        safeCall(function() self:UpdateSkeleton(dt) end)
        safeCall(function() self:UpdateTracer(dt) end)
        safeCall(function() self:UpdateHeadDot(dt) end)
        safeCall(function() self:UpdateChams() end)
        safeCall(function() self:UpdateWireframe() end)
        safeCall(function() self:UpdateRing() end)
        safeCall(function() self:UpdateLookDirection(dt) end)
        safeCall(function() self:UpdateOffscreenArrows() end)
    end)
end

return espModule
